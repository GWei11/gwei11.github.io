<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo</title>
    <url>/2020/06/06/hexo/hexo/</url>
    <content><![CDATA[<h1 id="文章目录默认展开"><a href="#文章目录默认展开" class="headerlink" title="文章目录默认展开"></a>文章目录默认展开</h1><p><a href="https://blog.csdn.net/wugenqiang/article/details/88609066" target="_blank" rel="noopener">参考文章</a></p>
<p>对于想要通过点击目录来进行展开与收缩的，需要进行下面的操作，把</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;文章目录默认展开</span><br><span class="line">.post-toc .nav .nav-child &#123; display: block; &#125;</span><br></pre></td></tr></table></figure>

<p>里面的<code>.nav-child</code>去掉即可通过点击来实现目录的展开与收缩。</p>
<a id="more"></a>

<h1 id="新建菜单以及添加菜单图标"><a href="#新建菜单以及添加菜单图标" class="headerlink" title="新建菜单以及添加菜单图标"></a>新建菜单以及添加菜单图标</h1><p><a href="http://theme-next.iissnan.com/getting-started.html#menu-settings" target="_blank" rel="noopener">next官网</a></p>
<p>在官网中查看主题设定-&gt;菜单那部分，当我们新添加一个菜单是(比如我要添加阅读)，在<code>next</code>的配置文件中(<code>_config.yml</code>)里面找到下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  book: &#x2F;book || book #这里是新添加的菜单</span><br><span class="line"></span><br><span class="line"># Enable&#x2F;Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: tru</span><br><span class="line">  book: book（这里是图标）</span><br></pre></td></tr></table></figure>

<p>然后在开启的对应的语言文件中，比如我使用的是中文，那么就是在<code>zh-Hans.yml</code>文件中找到<code>menu</code>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br><span class="line">  <span class="attr">book:</span> <span class="string">阅读</span></span><br></pre></td></tr></table></figure>

<p>后面的book那一栏是后来添加的。需要注意的是在上面的第一个配置文件中所写的<code>book</code>是<a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a>中<code>icon</code>的名称，这样才可以在我们自己的页面显示出图标。</p>
<h1 id="添加社交功能之邮箱"><a href="#添加社交功能之邮箱" class="headerlink" title="添加社交功能之邮箱"></a>添加社交功能之邮箱</h1><p>在next主题配置文件搜索social:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:1744709138@qq.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br></pre></td></tr></table></figure>

<p>这里只是显示了邮箱，这些原来都是注释掉的，自己去掉前面的注释即可，需要注意的是邮箱前面的<code>mailto</code>是必须要保留的，还有最后面的<code>envelope</code>则是图标名字，也是不能修改的。</p>
<h1 id="友情链接的配置"><a href="#友情链接的配置" class="headerlink" title="友情链接的配置"></a>友情链接的配置</h1><p>在<code>next</code>主题配置文件中查找标签<code>links</code>并进行如下配置:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># title</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">Links</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">MacTalk:</span> <span class="string">http://macshuo.com/</span></span><br><span class="line">  <span class="attr">Title:</span> <span class="string">http://example.com/</span></span><br></pre></td></tr></table></figure>

<h1 id="实现聊天功能"><a href="#实现聊天功能" class="headerlink" title="实现聊天功能"></a>实现聊天功能</h1><p><a href="https://hoxis.github.io/hexo-next-daovoice.html" target="_blank" rel="noopener">查看转载文章</a></p>
<h1 id="添加近期文章展示"><a href="#添加近期文章展示" class="headerlink" title="添加近期文章展示"></a>添加近期文章展示</h1><p><a href="https://blog.csdn.net/wugenqiang/article/details/88581218" target="_blank" rel="noopener">查看转载文章</a></p>
<h1 id="显示文章的更新时间"><a href="#显示文章的更新时间" class="headerlink" title="显示文章的更新时间"></a>显示文章的更新时间</h1><p>在主题的配置文件中找到<code>updated_at</code>，然后将其值修改为<code>true</code>即可(这种方式应该是适用于5以后的版本)</p>
<p>对于以前的方式可以看这篇<a href="https://blog.csdn.net/ganzhilin520/article/details/79053399" target="_blank" rel="noopener">别人写的文章</a></p>
<h1 id="字数统计与阅读时长"><a href="#字数统计与阅读时长" class="headerlink" title="字数统计与阅读时长"></a>字数统计与阅读时长</h1><p><a href="https://www.cnblogs.com/php-linux/p/8418518.html" target="_blank" rel="noopener">查看转载文章</a></p>
<h1 id="添加版权信息"><a href="#添加版权信息" class="headerlink" title="添加版权信息"></a>添加版权信息</h1><p>在站点配置文件搜索<code>post_copyright</code>，将<code>enable</code>修改为<code>true</code>，添加<code>author</code>即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">3.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/3.0/</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">咖啡杯里的茶</span></span><br></pre></td></tr></table></figure>

<h1 id="修改文章底部的标签"><a href="#修改文章底部的标签" class="headerlink" title="修改文章底部的标签"></a>修改文章底部的标签</h1><p>修改模板 <code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h1 id="修改博客的背景图"><a href="#修改博客的背景图" class="headerlink" title="修改博客的背景图"></a>修改博客的背景图</h1><p>在<code>themes-&gt;next-&gt;source-&gt;css-&gt;_custom-&gt;custom.styl</code>添加如下的代码:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//背景图</span><br><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(https://i.loli.net/<span class="number">2019</span>/<span class="number">05</span>/<span class="number">02</span>/<span class="number">5</span>ccab829cdad9.jpg);</span><br><span class="line">    background-attachment: fixed; // 不随屏幕滚动而滚动fixed,scroll,inherit</span><br><span class="line">    background-repeat: no-repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺</span><br><span class="line">    background-size: cover; // contain等比例铺满屏幕 //cover拉伸铺满</span><br><span class="line">    background-position: bottom;//x,y轴调整</span><br><span class="line">    +<span class="selector-tag">mobile</span>()&#123;</span><br><span class="line">      //background-position: 0% -20%;https://i.loli.net/2019/05/02/5ccab829cdad9.jpg</span><br><span class="line">      //https://i.loli.net/2018/12/29/5c270fc2bfcad.png</span><br><span class="line">      background-image: url(https://i.loli.net/2019/05/02/5ccab829cdad9.jpg);</span><br><span class="line">      <span class="selector-tag">background-size</span>: <span class="selector-tag">cover</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面几个有<code>url</code>的地方换成自己想要使用的背景图的图片的外链地址即可。</p>
<h1 id="将文章归类到新建的菜单中"><a href="#将文章归类到新建的菜单中" class="headerlink" title="将文章归类到新建的菜单中"></a>将文章归类到新建的菜单中</h1><p>比如自己已经添加了新的菜单<code>book</code>，现在想要将新建的文章归类到<code>book</code>这个菜单下做法如下：</p>
<p>在menu下如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">    home: / || home</span><br><span class="line">    tags: /tags/ || tags</span><br><span class="line">    categories: /categories/ || th</span><br><span class="line">    archives: /archives/ || archive</span><br><span class="line">    book: categories/book || book</span><br></pre></td></tr></table></figure>

<p>最后一个book是我自己新建的分类。然后再写文章时添加如下头部信息:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">title: abc</span><br><span class="line">categories:</span><br><span class="line">  - book</span><br></pre></td></tr></table></figure>

<p>这样当你点击<code>book</code>那个菜单时就会先显示<code>abc</code>这篇文章。</p>
<p><a href="https://www.cnblogs.com/codebook/p/10312965.html" target="_blank" rel="noopener">参考链接</a></p>
<h1 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h1><p><a href="https://www.jianshu.com/p/ea78bdd0551f" target="_blank" rel="noopener">显示图片</a></p>
<h1 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h1><p><a href="https://blog.csdn.net/qq_40265501/article/details/80030627" target="_blank" rel="noopener">添加搜索</a></p>
<h1 id="添加打赏功能"><a href="#添加打赏功能" class="headerlink" title="添加打赏功能"></a>添加打赏功能</h1><p>在<code>next</code>主题的配置文件文件中加上下面的代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">wechatpay: /images/微信支付.jpg</span><br><span class="line">alipay: /images/支付宝支付.jpg</span><br></pre></td></tr></table></figure>

<p>其中<code>wechatpay</code>和<code>alipay</code>对应的是微信支付收款码和支付宝支付收款码的图片地址，我这里是存放在 <code>主题\source\images\</code>下面</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>githubPag自定义域名以及两台电脑使用hexo</title>
    <url>/2020/06/06/hexo/githubPags/</url>
    <content><![CDATA[<h1 id="githubPag自定义域名"><a href="#githubPag自定义域名" class="headerlink" title="githubPag自定义域名"></a>githubPag自定义域名</h1><p><a href="https://blog.csdn.net/heimu24/article/details/81159099" target="_blank" rel="noopener">查看文章</a></p>
<a id="more"></a>

<h1 id="多台电脑使用hexo"><a href="#多台电脑使用hexo" class="headerlink" title="多台电脑使用hexo"></a>多台电脑使用hexo</h1><h2 id="不修改主题"><a href="#不修改主题" class="headerlink" title="不修改主题"></a>不修改主题</h2><p><a href="https://blog.csdn.net/ShmilyCoder/article/details/79916973" target="_blank" rel="noopener">查看文章</a></p>
<p>需要注意的是如果后续只是写博客而没有修改主题等文件的话只需使用hexo分支来操作即可。</p>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>如果需要修改主题的话依然是需要在搭建博客的电脑上搭建博客的那个目录(<code>hexo</code>)，使用两台电脑来写博客时都是使用的是后来创建的分支，此时修改主题则是在博客搭建目录里面去修改，修改完之后直接在博客搭建目录使用<code>git bash</code>，然后通过<code>hexo clean</code>， <code>hexo d -g</code>, 将修改的主题发布出去，但是此时需要注意的是当我们发布之后再去访问自己的博客发现文章可能会少很多，这很正常，因为我们后来写的博客都是在创建的分支上面去写的，最开始创建博客的那个目录并没有维护起来，此时看到的博客其实是最开始创建博客的那个目录里面的文章，所以此时只需要将修改的那部分主题文件拷贝到我们的分支目录对应位置，然后提交并且在在分支目录里面重新<code>hexo clean</code>， <code>hexo d -g</code>一次就可以了。以后只要不修改主题文件就都是在分支上操作了，只要需要修改主题文件时才需要在最开始创建博客的那个目录去操作然后拷贝到分支上并提交。</p>
<p><font color="green">我们创建博客的那个目录并不是一个<code>repository</code>，所以在那个目录是不能使用git命令的，只是我们将其余github进行了关联而已，所以在那里面只能使用hexo命令。</font></p>
<p><font color="red">经过测试，不是非要在创建博客的那台上脑上该样式才有作用，实际上在另外的一台电脑上直接修改样式也是有效果的。</font></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>连接mysql数据库的配置</title>
    <url>/2020/06/06/datasource/mysql/%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;property</span> <span class="string">name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;</span></span><br><span class="line"><span class="meta">&lt;property</span> <span class="string">name="url" value="jdbc:mysql://localhost:3306/spring"/&gt;</span></span><br><span class="line"><span class="meta">&lt;property</span> <span class="string">name="username" value="root"/&gt;</span></span><br><span class="line"><span class="meta">&lt;property</span> <span class="string">name="password" value="admin"/&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>datasource</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>datasource</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>委派模式</title>
    <url>/2020/06/06/java/design/%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>委派模式主要的基本作用是负责任务的调用和分配，和代理模式很类似。但是还是有一定的区别的</p>
<ul>
<li>代理模式注重过程</li>
<li>委派模式注重结果</li>
</ul>
<a id="more"></a>

<p>委派模式在<code>spring</code>中的典型应用就是<code>DispatcherServlet</code>，之前没有使用<code>springMVC</code>框架，也就是使用原生的<code>servlet</code>的时候，是每一个不同的请求都有一个映射地址(这个映射地址在<code>web.xml</code>中进行配置)，这个映射地址就是对应到该请求的处理类，使用<code>springMVC</code>框架之后，我们都是直接将请求映射到<code>controller</code>中的方法中，那么是怎么直接映射到方法中的呢，其实<code>DispatcherServlet</code>类就是充当的委派者的模式，我们所有的请求都会被<code>DispatcherServlet</code>这个类拦截，然后在这个类中进行任务调度。</p>
<p>来看一下委派模式的案例。</p>
<h1 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h1><h2 id="涉及对象"><a href="#涉及对象" class="headerlink" title="涉及对象"></a>涉及对象</h2><ul>
<li>boss</li>
<li>leader</li>
<li>employee</li>
</ul>
<p>来看一下这几个<code>UML</code>类图的关系</p>
<p><img src="/2020/06/06/java/design/%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F/image-20200510124652137.png" alt="image-20200510124652137"></p>
<ul>
<li><code>Boss</code>中有<code>leader</code>的引用，</li>
<li><code>Boss</code>给<code>leader</code>下达任务</li>
<li><code>leader</code>将任务委派给具体的员工去做</li>
</ul>
<p>Boss类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designmode.delegatepattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Leader leader = <span class="keyword">new</span> Leader();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String command)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leader.doSomething(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leader类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designmode.delegatepattern;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, IEmployee&gt; register = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        register.put(<span class="string">"技能A"</span>, <span class="keyword">new</span> EmployeeA());</span><br><span class="line">        register.put(<span class="string">"技能B"</span>, <span class="keyword">new</span> EmployeeB());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        register.get(command).doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>员工接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designmode.delegatepattern;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEmployee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体员工类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designmode.delegatepattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeA</span> <span class="keyword">implements</span> <span class="title">IEmployee</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是员工A,我擅长技能A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designmode.delegatepattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeB</span> <span class="keyword">implements</span> <span class="title">IEmployee</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是员工B,我擅长技能B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designmode.delegatepattern;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatePatternTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Boss boss = <span class="keyword">new</span> Boss();</span><br><span class="line">        boss.doSomething(<span class="string">"技能A"</span>);</span><br><span class="line">        boss.doSomething(<span class="string">"技能B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程下的七种单例模式</title>
    <url>/2020/06/06/java/design/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>本文主要分析七种形式的单例模式</p>
<ol>
<li>饿汉式</li>
<li>懒汉式</li>
<li>懒汉式加同步方法</li>
<li><code>DCL(double check locking)</code></li>
<li><code>volatile+double-check</code></li>
<li><code>holder</code></li>
<li>枚举</li>
</ol>
<p><a href="https://gitee.com/Gwei11/code/tree/master/javabase/testsingleton" target="_blank" rel="noopener">代码地址</a></p>
<a id="more"></a>

<h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><ul>
<li>所谓饿汉式就是一开始就将对象创建出来</li>
<li>构造方法私有</li>
<li>提供获取实例的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getHungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(getHungrySingleton());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>线程安全</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>非懒加载模式，性能不高</li>
</ul>
<h2 id="序列化破坏单例模式"><a href="#序列化破坏单例模式" class="headerlink" title="序列化破坏单例模式"></a>序列化破坏单例模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton.seriable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriableSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SeriableSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SeriableSingleton seriableSingleton = <span class="keyword">new</span> SeriableSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeriableSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seriableSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton.seriable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSeriableSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个对象想要从序列化中获取</span></span><br><span class="line">        SeriableSingleton s1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从系统中获取一个对象</span></span><br><span class="line">        SeriableSingleton s2 = SeriableSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"SeriableSingleton.obj"</span>);</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(s2);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"SeriableSingleton.obj"</span>);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">            s1 = (SeriableSingleton) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(s1);</span><br><span class="line">            System.out.println(s2);</span><br><span class="line">            System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img src="/2020/06/06/java/design/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200510064203998.png" alt="image-20200510064203998"></p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>在饿汉式代码中提供一个<code>readResolve()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton.seriable;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriableSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SeriableSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SeriableSingleton seriableSingleton = <span class="keyword">new</span> SeriableSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeriableSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seriableSingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  seriableSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>看一下<code>ObjectInputStream</code>的代码</p>
<p><img src="/2020/06/06/java/design/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200510070522882.png" alt="image-20200510070522882"></p>
<p>在最后的<code>readOrdinaryObject</code>方法中会有一个判断，就是如果我们序列化的类中含有<code>readResolve</code>这个方法的话，就用这个方法的返回值对象来替换反序列化出来的对象，所以使用这个方法不代表反序列化出来的对象和我们在系统中创建的对象是同一个，实际上反序列化出来的对象还是和系统中创建的不同的，只是使用了这个方法的话，就将这个这个方法的返回值重新赋值给反序列化出来的对象。</p>
<h3 id="再一次实验"><a href="#再一次实验" class="headerlink" title="再一次实验"></a>再一次实验</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton.seriable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriableSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SeriableSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SeriableSingleton seriableSingleton = <span class="keyword">new</span> SeriableSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeriableSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seriableSingleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SeriableSingleton object = <span class="keyword">new</span> SeriableSingleton();</span><br><span class="line">        System.out.println(<span class="string">"对象是："</span> + object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次我们将<code>readResolve</code>方法的返回值不是直接返回<code>seriableSingleton</code>，而是重新创建了一个对象，现在我们来看一下运行结果</p>
<p><img src="/2020/06/06/java/design/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200510071058755.png" alt="image-20200510071058755"></p>
<p>可以看到反序列的对象和<code>readResolve</code>方法返回值对象是同一个。</p>
<h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><ul>
<li>懒汉式就是当使用的时候才会创建这个对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazySingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(getInstance());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方式会有线程问题</p>
<p><img src="/2020/06/06/java/design/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200427223314728.png" alt="image-20200427223314728"></p>
<h2 id="线程不安全分析"><a href="#线程不安全分析" class="headerlink" title="线程不安全分析"></a>线程不安全分析</h2><p><img src="/2020/06/06/java/design/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200427234805848.png" alt="image-20200427234805848"></p>
<p>如上图所示，</p>
<ul>
<li>线程1执行到 <code>if(lazySinleton == null)</code>的时候时间片使用完</li>
<li>线程2进入到这块代码，由于线程1还没有创建出对象，所以线程2进来，为空的判断仍然是成立的</li>
<li>线程2进入<code>if</code>并且创建了对象</li>
<li>线程1在前面已经进入了<code>if</code>判断，只是还没有创建对象而已，现在轮到线程1了，那么线程1会继续执行创建对象的代码</li>
<li>这样就出现了多个对象，也就是线程安全的问题</li>
</ul>
<h1 id="懒汉式加同步方法"><a href="#懒汉式加同步方法" class="headerlink" title="懒汉式加同步方法"></a>懒汉式加同步方法</h1><p>上面看到懒汉式可以做到懒加载，但是存在线程不安全的问题，所以可以通过加锁的方式来解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonWithLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingletonWithLock lazySingleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingletonWithLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingletonWithLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazySingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lazySingleton = <span class="keyword">new</span> LazySingletonWithLock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(getInstance());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面代码所示，也就是在获取实例的代码中加上<code>synchronized</code>关键字，这样可以保证线程安全，但是当在方法中加上<code>synchronized</code>关键字之后就相当于是退化为串行了，因为加上了<code>synchronized</code>关键字时，该方法会被一个线程锁住，其余的线程想要进入该方法就必须要上一个线程退出才行，所以就相当于是单线程了，不能发挥多线程的优势。解决方式请看<code>DCL</code>方式</p>
<h1 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h1><p>所谓<code>DCL</code>方式就是<code>double check lock</code>，就是双重判断，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DCL lazySingleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCL <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazySingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DCL<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lazySingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lazySingleton = <span class="keyword">new</span> DCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(getInstance());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面代码所示，就是在获取实例的方法中做了两个判断，在懒汉式中已经分析为什么会出现线程安全问题，现在加锁之后再判断一次就可以解决这个问题。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>上面的代码中如果换成下面这样有没有效果？为什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DCL lazySingleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCL <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (DCL<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (lazySingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazySingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lazySingleton = <span class="keyword">new</span> DCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(getInstance());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是将<code>synchronized</code>放在第一个<code>if</code>判断的外面，而不是里面。这样做和第一种方式有什么区别？</p>
<p>其实这样锁定和在方法中锁定没有太大的区别，因为已进入方法就锁定了，那么进入方法里面的其实也只有一个线程，然后再去执行<code>if</code>判断，那么执行一次和执行两次<code>if</code>判断是没有区别的。</p>
<h1 id="volatile-DCL"><a href="#volatile-DCL" class="headerlink" title="volatile+DCL"></a>volatile+DCL</h1><p>上面<code>DCL</code>方法可以解决线程安全，并且是懒加载的方式，但是还是可能会有问题，因为上面的案例中是只有一个实例变量，如果这个类中还有其余的变量。先看下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileAndDCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> VolatileAndDCL lazySingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如一个类中有这样的两个变量，变量的实例化在字节码层面是在<init>方法中进行初始化的，在代码层面第一个变量是在第二个变量的后面，所以会讲道理在实例化<code>lazySingleton</code>的时候<code>connection</code>应该是已经实例化了，但是<code>jvm</code>可能会发生指令重排，所以可能<code>lazySingleton</code>实例化的时候，<code>connection</code>还没有被实例化，这样就会发生一个问题，当线程1实例化了<code>lazySingleton</code>，然后线程2拿到<code>lazySingleton</code>，因为<code>lazySingleton</code>已经不为空，所以线程2不会执行实例化的代码，这样当线程2在使用<code>connection</code>的时候就会出现空指针异常，此时可以使用<code>volatile</code>关键字来解决，这个关键字就是让强制让<code>jvm</code>不进行指令重排。</init></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileAndDCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> VolatileAndDCL lazySingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在<code>lazySingleton</code>前面的代码一定会先执行到。</p>
<h1 id="holder"><a href="#holder" class="headerlink" title="holder"></a>holder</h1><p>还有一种更巧妙的方式是通过静态内部类的方式来实现单例模式</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HolderDemo lazySingleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HolderDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> HolderDemo holderDemo = <span class="keyword">new</span> HolderDemo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HolderDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.holderDemo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4000</span>; i++) &#123;</span><br><span class="line">                System.out.println(getInstance());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于使用静态内部类的方式需要知道两点</p>
<ul>
<li><p>一个类只会被初始化一次</p>
</li>
<li><p>初始化外部类的时候并不会立即将内部类也初始化，看下面代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"内部类的静态块"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> InitializationTime());</span><br><span class="line">        <span class="comment">//System.out.println(new InnerClass());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上面的代码只是实例化外部类，打印结果如下：</p>
<p>  <img src="/2020/06/06/java/design/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200427232726260.png" alt="image-20200427232726260"></p>
<p>  通过上面的截图可以知道，内部类的<code>static</code>块的内容并没有并执行，说明内部类是没有初始化的，内部类的初始化时机是只有当内部类被使用的时候才会初始化。</p>
</li>
</ul>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>这种方式效率高，毕竟没有使用到<code>synchronized</code>，但是还是有办法破坏单例，那就是使用反射，看下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongHolderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = HolderDemo<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object o = constructor.newInstance();</span><br><span class="line">            HolderDemo instance = HolderDemo.getInstance();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            System.out.println(instance);</span><br><span class="line">            System.out.println(o == instance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img src="/2020/06/06/java/design/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20200508223400660.png" alt="image-20200508223400660"></p>
<p>可以看到在<code>HolderDemo</code>类中构造方法是私有的，但是使用反射还是可以创建出对象的。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p><code>java</code>是强大的，只有你想不到，没有<code>java</code>做不到，如果你想限制别人使用反射的方式来创建对象，那么只需要在构造方法中加上一个判断就好，完整代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HolderDemo lazySingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HolderDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Holder.holderDemo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">"已经被初始化过"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> HolderDemo holderDemo = <span class="keyword">new</span> HolderDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HolderDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.holderDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(getInstance());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在私有构造方法中加上了一个判断，如果已经实例化了<code>Holder.holderDemo</code>字段，那么就抛出异常，你可能会有疑问，当我使用反射创建的时候，第一次<code>Holder.holderDemo</code>这里的判断不应该是<code>null</code>么，这样不就可以创建成功了。别忘了上面说的内部类的加载时机咯，你看<code>getInstance()</code>方法其实也就是返回<code>Holder.holderDemo</code>而已，所以<code>if (Holder.holderDemo != null)</code> 这个判断不仅仅是一个判断，当你调用到这里来的时候就会实例化内部类的静态字段，所以在这里<code>Holder.holderDemo</code>的值就不会是<code>null</code>。</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>上面是通过内部类来实现的，还有一种方式是通过枚举来实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsingleton;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延迟加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> EnumHolder &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> EnumSingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        EnumHolder() &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> EnumSingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EnumSingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//懒加载</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EnumHolder.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(EnumSingletonDemo.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不熟悉枚举的同学，请前往<a href="[https://www.personalstudy.ltd/2020/05/30/java/%E6%9E%9A%E4%B8%BE/%E6%9E%9A%E4%B8%BE/](https://www.personalstudy.ltd/2020/05/30/java/枚举/枚举/)">枚举</a>。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/06/06/java/design/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>java中有疑惑的问题</title>
    <url>/2020/06/06/java/base/java%E4%B8%AD%E6%9C%89%E7%96%91%E6%83%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="java中为什么只有值传递-没有引用传递"><a href="#java中为什么只有值传递-没有引用传递" class="headerlink" title="java中为什么只有值传递,没有引用传递"></a>java中为什么只有值传递,没有引用传递</h1><p><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/why-pass-by-reference" target="_blank" rel="noopener">参考地址</a></p>
<h1 id="为什么java中byte类型的取值范围是-128到127"><a href="#为什么java中byte类型的取值范围是-128到127" class="headerlink" title="为什么java中byte类型的取值范围是-128到127"></a>为什么<code>java</code>中<code>byte</code>类型的取值范围是-128到127</h1><p><a href="https://blog.csdn.net/qq_23418393/article/details/57421688" target="_blank" rel="noopener">参考地址</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java中boolean类型属性定义为什么不要使用is开头</title>
    <url>/2020/06/06/java/base/java%E4%B8%ADboolean%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81is%E5%BC%80%E5%A4%B4/</url>
    <content><![CDATA[<h1 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h1><p><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/success-isSuccess-and-bollean-Bollean" target="_blank" rel="noopener">参考地址</a></p>
<a id="more"></a>

<h1 id="boolean和Boolean类型属性不使用is开头"><a href="#boolean和Boolean类型属性不使用is开头" class="headerlink" title="boolean和Boolean类型属性不使用is开头"></a>boolean和Boolean类型属性不使用is开头</h1><p>看下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> setterproperty;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanProperty</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAaa;</span><br><span class="line">    <span class="keyword">private</span> Boolean bbb;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isCcc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ddd;</span><br><span class="line">    <span class="keyword">private</span> String isEee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIsEee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsEee</span><span class="params">(String isEee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isEee = isEee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getAaa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAaa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAaa</span><span class="params">(Boolean aaa)</span> </span>&#123;</span><br><span class="line">        isAaa = aaa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getBbb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bbb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBbb</span><span class="params">(Boolean bbb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bbb = bbb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isCcc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCcc</span><span class="params">(<span class="keyword">boolean</span> ccc)</span> </span>&#123;</span><br><span class="line">        isCcc = ccc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ddd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDdd</span><span class="params">(<span class="keyword">boolean</span> ddd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ddd = ddd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了<strong>三类</strong>， <strong>五个</strong>属性，并且生成了<code>set</code>和<code>get</code>方法</p>
<ul>
<li><code>Boolean</code>类型，属性分别带有<code>is</code>开头和不带有<code>is</code>开头（包装类）</li>
<li><code>boolean</code>类型，属性分别带有<code>is</code>开头和不带有<code>is</code>开头（基本类型）</li>
<li><code>string</code>类型，属性分别带有<code>is</code>开头和不带有<code>is</code>开头</li>
</ul>
<p>上面的<code>set</code>和<code>get</code>方法是<code>idea</code>自动生成的，可以看到对于<code>Boolean</code>以及<code>boolean</code>类型的属性，如果是以<code>is</code>开头的，那么在生成<code>set</code>方法的时候不是在前面加上<code>set</code>，而是直接使用<code>is</code>开头，对于其他类型的值没有影响。</p>
<h1 id="Boolean和boolean的区别"><a href="#Boolean和boolean的区别" class="headerlink" title="Boolean和boolean的区别"></a>Boolean和boolean的区别</h1><p>看一下阿里巴巴<code>java</code>开发手册中对于基本类型和包装类型的使用标准</p>
<p><img src="/2020/06/06/java/base/java%E4%B8%ADboolean%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81is%E5%BC%80%E5%A4%B4/640.jpeg" alt="img"></p>
<p>其实也很容易理解，因为基本数据类型都是有默认值的，但是包装数据类型没有默认值。所以程序如果使用基本类型，那么有可能不是我们想要的结果，但是由于有默认值，程序并没有抛出异常，但是结果不对（对于结果不对时不应该使用默认值计算，而是应该我们自己处理）。若使用包装类型，当程序返回<code>null</code>的时候就说明此时结果已经是不对的，需要我们自己去处理。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2020/06/06/java/design/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p>
<a id="more"></a>

<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>比如我们平时买东西付款方式可以用多种</p>
<ul>
<li>支付宝支付</li>
<li>微信支付</li>
<li>银联支付</li>
<li>京东白条支付</li>
</ul>
<p>现在来看一下平时我们代码应该如何写。</p>
<h2 id="不使用策略模式"><a href="#不使用策略模式" class="headerlink" title="不使用策略模式"></a>不使用策略模式</h2><h3 id="支付订单类"><a href="#支付订单类" class="headerlink" title="支付订单类"></a>支付订单类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designmode.strategypattern.normal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> designmode.strategypattern.MsgResult;</span><br><span class="line"><span class="keyword">import</span> designmode.strategypattern.PayStrategy;</span><br><span class="line"><span class="keyword">import</span> designmode.strategypattern.Payment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Tom.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NormalOrder</span><span class="params">(String uid, String orderId, <span class="keyword">double</span> amount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pay</span><span class="params">(String payKey)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"京东"</span>.equals(payKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"使用京东支付，支付成功"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"支付宝"</span>.equals(payKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"使用支付宝支付，支付成功"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"微信"</span>.equals(payKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"使用微信支付,支付成功"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"支付方式错误"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designmode.strategypattern.normal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalOrderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NormalOrder order = <span class="keyword">new</span> NormalOrder(<span class="string">"1"</span>, <span class="string">"13424123432"</span>, <span class="number">33.22</span>);</span><br><span class="line">        System.out.println(order.pay(<span class="string">"支付宝"</span>));</span><br><span class="line">        System.out.println(order.pay(<span class="string">"微信"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>加上后面还有别的支付方式，我们就一直需要修改<code>NormalOrder</code>类的<code>pay</code>方法，需要在里面不断的加上判断，去修改支付逻辑，这就违背了开闭原则。</p>
<h2 id="使用策略模式"><a href="#使用策略模式" class="headerlink" title="使用策略模式"></a>使用策略模式</h2><p>先看一下使用策略模式的<code>UML</code>类图</p>
<p><img src="/2020/06/06/java/design/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-20200510204800618.png" alt="image-20200510204800618"></p>
<p>从上面的类图中可以看到主体是分为三类</p>
<ul>
<li><code>payment</code>接口或抽象类和具体的支付方式<ul>
<li>因为支付都有相似的功能，比如支付类型，判断该支付类型下账号的余额等，所以需要有一个接口或者抽象类，然后具体的支付方式来实现或者继承这个接口或抽象类。</li>
</ul>
</li>
<li>具体策略，这里就是<code>PayStrategy</code>类，这个类的作用是给上层客户端来调用，获取具体的支付方式</li>
<li><code>order</code>类就是订单类，可以认为是客户端类</li>
</ul>
<p><a href="https://gitee.com/Gwei11/code/tree/master/javabase/strategypattern" target="_blank" rel="noopener">策略模式代码</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的集合</title>
    <url>/2020/06/06/java/base/java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java中自动拆装箱和缓存机制</title>
    <url>/2020/06/06/java/base/java%E4%B8%AD%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> automaticpacking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPackage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自动装箱</span></span><br><span class="line">        Integer i = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 自动拆箱</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="两种方式查看自动拆装箱的代码"><a href="#两种方式查看自动拆装箱的代码" class="headerlink" title="两种方式查看自动拆装箱的代码"></a>两种方式查看自动拆装箱的代码</h2><h3 id="反编译法"><a href="#反编译法" class="headerlink" title="反编译法"></a>反编译法</h3><p>将上面的代码使用<code>javap</code>命令反编译一下：</p>
<p><img src="/2020/06/06/java/base/java%E4%B8%AD%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/image-20200422224048061.png" alt="image-20200422224048061"></p>
<p>可以看到其实自动拆装箱是通过<code>Integer.valueOf()</code>和<code>Integer.intValue()</code></p>
<h3 id="调试法"><a href="#调试法" class="headerlink" title="调试法"></a>调试法</h3><p>上面是通过反编译的形式可以知道底层调用的代码是什么，其实中<code>idea</code>中还有一种方式是断点调试</p>
<p><img src="/2020/06/06/java/base/java%E4%B8%AD%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/image-20200422225116752.png" alt="image-20200422225116752"></p>
<p>可以看到上面的图片，可以点击<code>force step into</code>来进入代码。</p>
<h4 id="step-into-和-force-step-into的区别"><a href="#step-into-和-force-step-into的区别" class="headerlink" title="step into 和 force step into的区别"></a><code>step into</code> 和 <code>force step into</code>的区别</h4><ul>
<li><code>step into</code>可以进入自己写的方法内部去调试</li>
<li><code>force step into</code>可以进入任何方法内部进行调试，由于这里我们是要进入<code>jdk</code>的包内部代码进行调试，所以需要使用<code>force step into</code></li>
</ul>
<h1 id="Integer类型的缓存问题"><a href="#Integer类型的缓存问题" class="headerlink" title="Integer类型的缓存问题"></a>Integer类型的缓存问题</h1><p>看下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> automaticpacking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPackage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">100</span>;</span><br><span class="line">        Integer j = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">200</span>;</span><br><span class="line">        Integer j2 = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">int</span> j3 = <span class="number">300</span>;</span><br><span class="line">        System.out.println(i == j); <span class="comment">// true</span></span><br><span class="line">        System.out.println(i2 == j2); <span class="comment">// false</span></span><br><span class="line">        System.out.println(i3 == j3); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码输出个结果是不是有点奇怪， 第二个结果和第三个结果还是比较号理解的</p>
<ul>
<li>基本类型的比较肯定比较值就可以咯。所以输出结果为<code>true</code>没有疑问</li>
<li>包装类型为什么第一个是<code>true</code>，第二个是<code>false</code>呢</li>
</ul>
<h2 id="Integer类型缓存值"><a href="#Integer类型缓存值" class="headerlink" title="Integer类型缓存值"></a>Integer类型缓存值</h2><p>我们通过调试法看下 <code>Integer i = 100</code>这句代码是如何执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">      <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看源码就知道 <code>IntegerCache.low</code>固定为-128</li>
<li><code>IntegerCache.high</code>是可以配置的，看下源码注释<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>，所以可以通过这个参数类配置最大值。</li>
</ul>
<h2 id="包装类型的比较的坑"><a href="#包装类型的比较的坑" class="headerlink" title="包装类型的比较的坑"></a>包装类型的比较的坑</h2><p>上面只是分析了<code>Integer</code>类型，其实还有其他包装类型也是一样的有缓存的值，所以对于包装类型有一点需要知道，<strong>包装类型的比较最好都通过<code>equals</code>方法来进行比较</strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存模型</title>
    <url>/2020/06/06/java/jvm/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p><code>java</code>内存模型实际上是一个抽象的概念，是一套规范，而不是一个实际的东西，而<code>java</code>内存结构就是根据这一套规范来进行划分的。可以先看另一篇文章。</p>
<p><a href="https://gwei11.gitee.io/2020/04/23/java/jvm/jvm/#more" target="_blank" rel="noopener">jvm</a></p>
<p>对于<code>java</code>内存模型我们主要需要了解以下几个内容：</p>
<ul>
<li>硬件内存架构</li>
<li>线程和<code>jvm</code></li>
<li><code>java</code>内存模型</li>
<li><code>java</code>内存模型对并发编程的支持</li>
</ul>
<a id="more"></a>

<h1 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h1><blockquote>
<p>物理机遇到的并发问题与虚拟机中的情况有很多相似之处，物理机对并发的处理方案对虚拟机的实现也有相当大的参考意义</p>
</blockquote>
<p><img src="/2020/06/06/java/jvm/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20200425163052739.png" alt="image-20200425163052739"></p>
<p>如上图所示，在计算机模型中主要是有五个部分来组成的，其中<strong>处理器</strong>和<strong>控制器</strong>合起来就是我们所示的<code>cpu</code></p>
<p>运算器的运算速度都是很快的，但是我们的数据存储不可能所有数据都存放在寄存器中，所以数据的<code>io</code>操作都是很有必要 的，这样就不能充分利用<code>cpu</code>的运算能力，此时就需要<strong>加上读写速度和处理器运算速度差不多的的高速缓存</strong>来作为<strong>内存和处理器之间</strong>的缓冲。将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>
<h2 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h2><p>上面加上了缓存可以解决内存的读写速度赶不上处理器的运算速度问题，但是又出现了另外一个问题。<strong>缓存一致性问题</strong></p>
<p>因为 在多处理器中，每一个处理器都有自己的高速缓存，但是内存是只有一个。对于缓存一致性问题在硬件层面主要有两个解决方式</p>
<ul>
<li><p>总线加锁</p>
<ul>
<li>所谓的总线加锁就每一次都会锁定一个<code>cpu</code>，只有这个锁定的<code>cpu</code>才可以执行，其余的<code>cpu</code>是不能执行的。这种方式会降低<code>cpu</code>的吞吐量。</li>
</ul>
</li>
<li><p>使用缓存一致性协议，所谓使用缓存一致性协议也就是在缓存和主内存之间加上一个访问规则，通过这种规则来解决缓存一致性问题。</p>
</li>
</ul>
<p><img src="/2020/06/06/java/jvm/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20200425163335781.png" alt="image-20200425163335781"></p>
<p>这里的<strong>缓存一致性其实是一个协议</strong>，是处理缓存一致性问题的一个协议(也可以任认为是处理缓存一致性问题的一个理论基础)。</p>
<h1 id="java内存模型-java-memory-mode"><a href="#java内存模型-java-memory-mode" class="headerlink" title="java内存模型(java memory mode)"></a>java内存模型(java memory mode)</h1><h2 id="什么是java内存模型-JMM规范"><a href="#什么是java内存模型-JMM规范" class="headerlink" title="什么是java内存模型(JMM规范)"></a>什么是<code>java</code>内存模型(JMM规范)</h2><p><strong><code>java</code>内存模型其实也是一个理论上的东西，是一个规范，这个规范的主要目的是定义程序中各种变量的访问规则，也就是关注的是虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。</strong>此处的变量和<code>java</code>编程中的变量是不同的，这里的变量包含了实例字段，静态字段和构成数组对象的元素，但是不包括局部变量和方法参数。（上面这段话是《深入理解java虚拟机》这本书中的）</p>
<p><code>jvm</code>将内存组织结构主要划分为两个部分</p>
<ul>
<li>主内存</li>
<li>工作内存</li>
</ul>
<p><img src="/2020/06/06/java/jvm/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20200425164144343.png" alt="image-20200425164144343"></p>
<h3 id="主内存"><a href="#主内存" class="headerlink" title="主内存"></a>主内存</h3><ul>
<li>主要包含本地方法区和堆</li>
<li>所有变量都要存储在主内存中，这些变量对于所有线程都是共享的</li>
</ul>
<h3 id="工作内存"><a href="#工作内存" class="headerlink" title="工作内存"></a>工作内存</h3><ul>
<li>每一个线程都有自己独立工作的地方，也就是工作内存</li>
<li>工作内存中保存的是主内存中某些变量的拷贝，线程堆变量的所有操作都必须在工作内存中进行，不能直接操作主内存</li>
<li><strong>如果是基本数据类型，那么直接分配到工作内存，如果是引用类型，引用的地址存在在工作空间中，但是具体的对象是存在在堆中(也就是主内存中)，是可以共享的</strong></li>
</ul>
<p><img src="/2020/06/06/java/jvm/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20200423233046759.png" alt="什么是java内存模型"></p>
<p>看上图，之所以存在<code>java</code>内存模型一说是因为<code>java</code>虚拟机的工作机制。当有多个线程的时候，每一个线程可以操作的数据有两种类型</p>
<ul>
<li>线程私有的数据，也就是这个数据就算改变了也不会影响其余线程，比如说局部变量就是线程私有的数据</li>
<li>线程共享的数据，这样的数据多个线程都可以访问，就会出现线程安全的问题</li>
</ul>
<p>因为线程操作的数据有不同类型，所以在<code>java</code>中一个线程去操作数据的时候不是在主内存中直接操作，其实还有一个属于线程自己的内存(工作内存)，当操作线程私有的数据比较好理解，直接在工作内存中完成就可以咯，如果是操作共享的数据，那么就在主内存中拿一份数据到自己工作内存中操作，操作完了再将数据给到主内存中。</p>
<h2 id="内存结构和内存模型的关系"><a href="#内存结构和内存模型的关系" class="headerlink" title="内存结构和内存模型的关系"></a>内存结构和内存模型的关系</h2><p>上面说了什么是<code>java</code>的内存模型，知道<code>java</code>内存模型是一个规范，定义的是程序中变量的访问规则，那么这个内存模型和我们平时所有的内存结构有什么关系呢？先看一下<code>java</code>内存结构</p>
<h3 id="java内存结构"><a href="#java内存结构" class="headerlink" title="java内存结构"></a>java内存结构</h3><p><code>java</code>中内存结构主要是有五个部分</p>
<ul>
<li>程序计数器</li>
<li>堆</li>
<li>虚拟机栈<ul>
<li>存放方法运行时所需的数据，成为栈帧</li>
</ul>
</li>
<li>本地方法栈</li>
<li>方法区<ul>
<li>存储运行时常量池、已被虚拟机加载的类信息、常量、静态变量，即时编译后的代码等</li>
</ul>
</li>
</ul>
<p>上面<code>java</code>的五个部分其实就是根据<code>JMM</code>规范(<code>java</code>内存模型)来划分的一个内存结构。</p>
<h1 id="并发编程的三个特性"><a href="#并发编程的三个特性" class="headerlink" title="并发编程的三个特性"></a>并发编程的三个特性</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>执行的操作不可分割，可以理解为就是一步操作，因为只有一步所以肯定是不能分割的</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>线程都是有自己的工作空间的，每一个线程都只能操作自己工作空间的数据，别的线程是看不到自己线程的工作空间的数据的</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>程序中代码的顺序不一定就是在<code>cpu</code>中执行的顺序，因为存在两种重排</p>
<ul>
<li>编译重排序(编译期)</li>
<li>指令重排序(运行期)</li>
</ul>
<h1 id="JMM规范是如何保证并发编程的三个特征的呢"><a href="#JMM规范是如何保证并发编程的三个特征的呢" class="headerlink" title="JMM规范是如何保证并发编程的三个特征的呢"></a>JMM规范是如何保证并发编程的三个特征的呢</h1><h2 id="JMM和原子性"><a href="#JMM和原子性" class="headerlink" title="JMM和原子性"></a><code>JMM</code>和原子性</h2><h3 id="原子性案例1"><a href="#原子性案例1" class="headerlink" title="原子性案例1"></a>原子性案例1</h3><p><code>X = 10</code>这样一个操作具有原子性么？</p>
<ul>
<li>如果<code>X</code>是私有数据，是分配到工作空间的，那么就是有原子性的，因为只有一个写的操作</li>
<li>如果<code>X</code>是共享的数据，就是在主内存中，这样就需要先在主内存中读取(复制)到工作空间中，修改完成后再将数据通过到主内存中，这样就是两步，也就是没有原子性</li>
</ul>
<h3 id="原子性案例2"><a href="#原子性案例2" class="headerlink" title="原子性案例2"></a>原子性案例2</h3><p><code>i++</code>这个操作具有原子性么？</p>
<p><code>i++</code>这个操作其实是需要分为下面这几个步骤的</p>
<ul>
<li>读取<code>i</code>的值</li>
<li>将<code>i</code>的值加一</li>
<li>将修改后的值赋值给<code>i</code></li>
</ul>
<p>可以看到每一步都是原子操作，但是这三个原子操作合在一起之后去不是原子操作了</p>
<h3 id="JMM如何保证原子性的"><a href="#JMM如何保证原子性的" class="headerlink" title="JMM如何保证原子性的"></a>JMM如何保证原子性的</h3><ul>
<li>使用<code>Synchronized</code>关键字</li>
<li>使用<code>JUC</code>的<code>lock</code>和<code>unlock</code>关键字</li>
</ul>
<h2 id="JMM和可见性"><a href="#JMM和可见性" class="headerlink" title="JMM和可见性"></a><code>JMM</code>和可见性</h2><p>线程是不能操作主内存中的数据的，只能操作自己的工作空间的数据，所以需要数据时会先去工作空间找，如果找到了就会使用工作空间中的数据，找不到才会从主内存中找，但是如果一个线程在工作空间找到了，不过这个数据在别的线程中已经修改了，并且刷新到主内中了，由于当前线程的工作空间中有这个数据，没有在主内存中拿，这样当前线程拿到的就不是最新的数据。<code>JMM</code>是如何解决这个问题的呢？</p>
<h3 id="JMM如何保证可见性的"><a href="#JMM如何保证可见性的" class="headerlink" title="JMM如何保证可见性的"></a><code>JMM</code>如何保证可见性的</h3><ul>
<li><code>Volatile</code>关键字，使用这个关键字后，当线程需要使用这个关键字修饰的数据时，每一次都会从主内存中去找数据，而不是从工作空间中找。</li>
<li><code>JUC</code>  可以使用<code>JUC</code>的<code>lock</code>和<code>unlock</code></li>
</ul>
<h2 id="JMM和有序性-重排序"><a href="#JMM和有序性-重排序" class="headerlink" title="JMM和有序性(重排序)"></a><code>JMM</code>和有序性(重排序)</h2><p>对于有序性问题可以使用下面两种方式来解决</p>
<ul>
<li>使用<code>Volatile</code>关键字</li>
<li>使用<code>Synchronized</code>来加锁</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java垃圾回收机制</title>
    <url>/2020/06/06/java/jvm/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="什么是jvm"><a href="#什么是jvm" class="headerlink" title="什么是jvm"></a>什么是jvm</h1><p><code>java Virtual Machine</code>也就是<code>java</code>程序运行的环境(<code>java</code>二进制字节码的运行环境)</p>
<h2 id="使用jvm的优势"><a href="#使用jvm的优势" class="headerlink" title="使用jvm的优势"></a>使用jvm的优势</h2><ul>
<li><p>使用<code>java</code>的程序员都知道，<code>java</code>是一次编写，处处运行的，那么为什么可以做到一次编写，处处运行呢？</p>
<p>  <a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/platform-independent" target="_blank" rel="noopener">java是如何实现平台无关的</a></p>
</li>
<li><p>自动内存管理，有垃圾回收功能</p>
</li>
</ul>
<a id="more"></a>

<h2 id="jdk、jre、jvm的区别"><a href="#jdk、jre、jvm的区别" class="headerlink" title="jdk、jre、jvm的区别"></a><code>jdk</code>、<code>jre</code>、<code>jvm</code>的区别</h2><p><img src="/2020/06/06/java/jvm/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20200423222219450.png" alt="image-20200423222219450"></p>
<h3 id="堆内存诊断工具"><a href="#堆内存诊断工具" class="headerlink" title="堆内存诊断工具"></a>堆内存诊断工具</h3><ul>
<li><code>jps</code>工具<ul>
<li>查看当前系统中有哪些<code>java</code>进程</li>
</ul>
</li>
<li><code>jmap</code>工具<ul>
<li>查看某一个时刻堆内存占用情形</li>
</ul>
</li>
<li><code>jconsole</code>工具<ul>
<li>图形界面，多功能的检测工具，可以连续检测</li>
</ul>
</li>
</ul>
<h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p><strong>注：</strong>下面我所有的命令都是在<code>idea</code>的<code>terminal</code>窗口执行的，其实只要配置了jdk环境变量，就可以在任意位置开启<code>cmd</code>窗口来执行也是一样的。</p>
<p>该工具的作用是查看当前系统中有那些<code>java</code>进程。就拿上面的案例代码来看，该命令是在<code>idea</code>中<code>local</code>窗口输入的。</p>
<p><img src="/2020/06/06/java/jvm/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20200423223652867.png" alt="image-20200423223652867"></p>
<p>使用<code>jps</code>命令可以查看到当前程序的进程<code>id</code>是8152</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>当我们思考<code>GC</code>(<code>Garbage Collection</code>)是需要思考三件事情：</p>
<ol>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<p>内存结构中的<strong>程序计数器</strong>，<strong>虚拟机栈</strong>，<strong>本地方法栈</strong>三个区域是随着线程而生的，栈中的栈帧随着方法进入和退出执行入栈和出栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来的时候就已经知道的(虽然在运行期间会由<code>JIT</code>编译器进行一些优化，不过大体上可以认为在编译期间就知道需要分配多少内存)，程序计数器是唯一个没有规定内存泄漏的区域，所以这几个区域是不用考虑内存回收的问题。<code>java</code>堆和方法区不一样，一个接口中多个实现类需要的内存可能不同，一个方法中的多个分支需要的内存也不一样，我们只有在程序处于运行的时候才知道需要创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的就是这部分内存(<strong>堆内存</strong>)。</p>
<h2 id="如何判断垃圾可以回收"><a href="#如何判断垃圾可以回收" class="headerlink" title="如何判断垃圾可以回收"></a>如何判断垃圾可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0<br>的对象就是不可能再被使用的。</p>
<p>但是<code>java</code>虚拟机不是使用这种方式来判断的，因为这种方式比较难以解决的一个问题就是<strong>循环引用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 该成员变量的作用是占用一点内存，可以在gc日志中判断对象是否被回收过</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">    ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">    objA.instance = objB;</span><br><span class="line">    objB.instance = objA;</span><br><span class="line">    objA = <span class="keyword">null</span>;</span><br><span class="line">    objB = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 下面的代码执行后，如果是通过引用计数法来判断对象是否可以回收的话，这两个对象是不会被回收的</span></span><br><span class="line">    System.gc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/06/java/jvm/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1574560215250.png" alt="1574560215250"></p>
<p>如上图所示，即使执行了<code>objA = null</code>和<code>objB=null</code>,但是实际上他们的实例还是存在者引用，如果按照引用计数法来判断话，这两个对象是不会被回收的，实际上这两个对象是被回收了。所以可以说明<code>java</code>虚拟机不是使用引用计数法来判断对象是否可回收的。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>该算法的基本思路是通过一系列的称为<code>GC Root</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径中称为引用链，当一个对象到<code>GC Root</code>没有任何引用链时(从图论的角度来看，就是从<code>GC Root</code>到这个对象不可达)证明这个对象是不可用的。</p>
<ul>
<li><code>java</code>虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li>
<li>扫描堆中的对象，看是否能够沿着<code>GC Root</code>对象为起点的引用链找到该对象，如果找不到，表示可以回收。</li>
</ul>
<h4 id="在java语法中，可作为GC-Root的对象包含以下几种"><a href="#在java语法中，可作为GC-Root的对象包含以下几种" class="headerlink" title="在java语法中，可作为GC Root的对象包含以下几种"></a>在<code>java</code>语法中，可作为<code>GC Root</code>的对象包含以下几种</h4><ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中<strong>类静态属性</strong>引用的对象</li>
<li>方法区中常量引用的对象,比如字符串常量池中引用的对象</li>
<li>本地方法栈中<code>JNI</code>(也就是<code>native</code>方法)中引用的对象。</li>
<li><code>java</code>虚拟机内部的引用，如基本数据类型对应的<code>Class</code>对象</li>
<li>所有被同步锁（<code>synchronized</code>关键字）持有的对象</li>
</ul>
<h4 id="不可达不一定死亡"><a href="#不可达不一定死亡" class="headerlink" title="不可达不一定死亡"></a>不可达不一定死亡</h4><p>即使是在可达性分析算法中不可达的对象，也不一定都是要被回收的，此时他们暂时处于缓刑阶段，要宣告一个对象死亡，至少需要经历<strong>两次标记过程</strong></p>
<ul>
<li>如果对象在进行可达性分析后发现没有与<code>GC Root</code>相连接的引用链，那么将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，当对象没有覆盖<code>finalize()</code>方法时，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这两种情形视为<strong>“没有必要执行”</strong></li>
<li>如果该对象判断为有必要执行<code>finalize()</code>方法，那么该对象将中被放置在一个叫做<code>F-Queue</code>队列中，并且在稍后由一个虚拟机自动建立的，优先级低的<code>Finalizer</code>线程去执行它。<code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后<code>GC</code>将对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果对象在<code>finalize()</code>中成功拯救自己(只要重新与引用链上的任何一个对象建立关联即可，比如将自己(<code>this</code>关键字)赋值给某个类变量或对象的成员变量，那么在第二次标记的时候会被将它移除“<strong>即将回收</strong>”的集合)，如果对象在此时还没有逃脱，那就说明需要被回收了。</li>
</ul>
<p><font color="red">注意：这种自救方式并不被推荐，最好不要使用这个方法</font></p>
<h3 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h3><ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用(存放直接内存地址，便于回收直接内存)</li>
<li>终结器引用</li>
</ul>
<blockquote>
<ul>
<li>软引用和弱引用可以联合引用队列来使用，也可以不结合引用队列来使用(之所以需要结合引用队列来使用，是引用软引用和弱引用自身也是需要占有一定的内存的，要想回收他们就需要在引用队列中找到他们才能回收)<ul>
<li>当发生GC时不一定就与回收软引用，只有当发生GC之后内存还是不足的时候才会回收软引用</li>
<li>当发生GC的时候弱引用就会被回收掉</li>
</ul>
</li>
<li>虚引用和终结器引用必须结合引用队列来使用</li>
</ul>
</blockquote>
<p>四种引用强度(不包含终结器引用)从大到小分别是：<strong>强引用-&gt;软引用-&gt;弱引用-&gt;虚引用</strong></p>
<p><strong>参考图</strong>（下图中有两个<code>GC Root</code>， 实线表示强引用）</p>
<p><img src="/2020/06/06/java/jvm/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1574564711687.png" alt></p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用表示从<code>GC Root</code>出发可以直接达到的，比如<code>Oeject object = new Object()</code>这类引用就是强引用。只要强引用还在，垃圾回收器就不会回收掉被引用的对象。</p>
<p>比如上面的<code>A1</code>对象被<code>B</code>对象和<code>C</code>对象都是直接引用到(当然实际上只要有一个强引用就可以算是强引用)，所以是一个强引用。</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用用来描述一些还有用但是不是必须的对象，对于软引用关联着的对象，在系统中<strong>将要发生内存溢出异常之前</strong>，将会把这些对象列进回收范围之内进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常，在<code>jdk1.2</code>之后，提供了<code>SoftReference</code>类来实现软引用。</p>
<p>比如上面的<code>A2</code>对象如果是从<code>C</code>对象的角度来看是一个软件用。（当然从B对象来看是强引用，所以垃圾回收是不会回收该对象的）</p>
<p><strong>软引用案例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置堆内存大小为<code>20M</code></p>
<p><img src="/2020/06/06/java/jvm/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1574567017819.png" alt></p>
<p>运行程序出现堆内存溢出错误：</p>
<p><img src="/2020/06/06/java/jvm/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1574567090459.png" alt></p>
<p>将程序修改为软引用的形式来做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        soft();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">soft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; reference = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">            System.out.println(reference.get());</span><br><span class="line">            list.add(reference);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"循环结束"</span>);</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时不会出现堆内存溢出错误而且<code>list</code>中前面四个都已经被回收掉了。当然除了配置堆内存大小外还可以配置显示gc回收的虚拟机运行参数；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用也是用来描述非必须的对象的，但是它的强度比软引用更弱一些，被弱引用关联的软引用只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，<strong>无论当前内存是否足够，都会回收掉被弱引用关联的对象</strong>，在<code>jdk1.2</code>之后，提供了<code>WeakReference</code>类来实现弱引用。</p>
<h4 id="软弱引用与引用队列"><a href="#软弱引用与引用队列" class="headerlink" title="软弱引用与引用队列"></a>软弱引用与引用队列</h4><p>软引用与若引用的区别在于他们的回收时机</p>
<ul>
<li>软引用是只有当内存空间不足时才会被回收</li>
<li>弱引用是无论内存空间是否足够都是会被回收的</li>
</ul>
<p>从上面的图可以看到，软引用与弱引用可以认为是间接引用，也就是根对象首先强引用一个软引用或弱引用，然后该软引用或弱引用再来引用一个对象，那么当这个对象（比如A2）当被回收时，<code>A2</code>所对应的软引用也是会占有一定的内存的，如果想要回收这个内存空间就需要<code>A2</code>对应的软引用进入到引用队列中，然后在引用队列中进行遍历的时候回收这个内存(对于弱引用也是同样的道理)。</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p><strong>软弱引用可以配置引用队列使用，也可以不用配合引用队列来使用，但是虚引用就必须配合引用队列来使用</strong></p>
<p>虚引用也被称为幽灵引用或幻影引用，他是最弱的一种引用关系，一个对象是否与虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通过，在<code>jdk1.2</code>之后，提供了<code>PhantomReference</code>来实现虚引用。</p>
<p><strong>使用案例：</strong></p>
<p>当我们使用<code>ByteBuffer</code>时是会创建一个直接内存，同时也会创建一个<code>Cleaner</code>的虚引用，当<code>ByteBuffer</code>被垃圾回收时，它所分配的直接内存是不会被回收的，因为直接内存是不受<code>java</code>虚拟机管理的，此时就需要使用的<code>Cleaner</code>的虚引用了，因为当<code>ByteBuffer</code>回收时，该虚引用就会进入到引用队列，引用队列里面会检测是否有<code>Cleaner</code>虚引用，如果有就会调用<code>clear</code>方法，该方法最终会调用<code>Unsafe.freeMemory()</code>来释放掉这一块直接内存。</p>
<h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><p>终结器引用也是需要配合引用队列来使用的。</p>
<p>每一个对象都有一个终极父类<code>Object</code>，<code>Object</code>类中有一个<code>finalize()</code>方法，如果我们重写了这个方法，那么这个方法的调用时机是什么呢?这就需要使用的终结器引用了。<strong>当没有强引用来关联该对象的时候，虚拟机会帮我们创建终结器匀变速，并终结器就会进入到引用队列(此时该对象还没有被回收)。</strong>有一个优先级很低的线程会检查引用队列中是否有终结器引用，如果有就会根据该终结器引用找到对应对象的<code>finalize()</code>方法。</p>
<p><font color="red">注意：通过终结器引用来释放资源的方式效率很低，多以一般是不推荐使用finalize()方法了释放资源。</font></p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ul>
<li>速度快</li>
<li>会造成内存碎片</li>
</ul>
<p><img src="/2020/06/06/java/jvm/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1574575683561.png" alt="1574575683561"></p>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><ul>
<li>速度慢</li>
<li>没有内存碎片</li>
</ul>
<p><img src="/2020/06/06/java/jvm/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1574575714962.png" alt="1574575714962"></p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul>
<li>没有内存碎片</li>
<li>需要占用双倍的内存空间</li>
</ul>
<p><img src="/2020/06/06/java/jvm/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1574575757476.png" alt="1574575757476"></p>
<p><code>jvm</code>中并不是只是使用某一种算法，而是在不同的情形下会使用不同的算法，也有可能结合起来使用。</p>
<h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><p><img src="/2020/06/06/java/jvm/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/1574576757717.png" alt="1574576757717"></p>
<ul>
<li>对象首先分配在<strong>伊甸园</strong>区域</li>
<li>新生代空间不足时，触发<code>minor gc</code>,伊甸园和<code>from</code>区存活的对象使用<strong>复制算法</strong>复制到<code>to</code>区，存活的对象年龄加1并且交换<code>from</code>区和<code>to</code>区</li>
<li><code>minor gc</code>会引发 <code>stop the world</code>,暂停其他用户的线程，等待垃圾回收结束，用户线程才恢复</li>
<li>当对象寿命超过阈值时，会将对象移入到老年代，最大寿命是15(使用4bit来存储该值，所以最大是15)</li>
<li>当老年代空间不足，会先尝试触发 <code>minor gc</code>，如果之后空间还是不足，那么会触发<code>full gc</code>,<code>SWT</code>的时间更长。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm的内存结构</title>
    <url>/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="jvm的内存结构"><a href="#jvm的内存结构" class="headerlink" title="jvm的内存结构"></a>jvm的内存结构</h1><p><code>java</code>内存结构主要划分为五大部分</p>
<ul>
<li>线程私有的三个<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
</li>
<li>线程共享的两个<ul>
<li><strong>堆</strong></li>
<li><strong>方法区</strong></li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><code>Program Counter Register</code>程序计数器(寄存器)</p>
<p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200423222321549.png" alt="image-20200423222321549"></p>
<p>如上图所示：<code>java</code>源代码到生成对象是有一个过程的</p>
<ol>
<li><code>java</code>源文件首先需要经过编译器编译成字节码<code>.class</code>文件，字节码文件中其实就是一条条的<code>jvm</code>指令，这些指令是不能直接到<code>cpu</code>中执行的，所以需要第二步。</li>
<li>第二步这些字节码的<code>jvm</code>指令会被解释器解释成<strong>机器码</strong></li>
<li>机器码可以直接被<code>cpu</code>识别并执行</li>
<li>要知道指令不是只有一条，那么当执行完这一条指令后，如何知道下一条要执行的是什么指令呢？此时就需要 使用到<strong>程序计数器</strong>，<strong>程序计数器的作用就是保存程序需要执行的下一条<code>jvm</code>指令.</strong></li>
<li>程序计数器的物理实现是寄存器.</li>
</ol>
<h3 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h3><ul>
<li>线程私有</li>
<li>唯一一个不会存在内存溢出的区域</li>
<li>如果执行的是本地方法，则程序计数器中值为空</li>
<li>程序计数器的物理实现为寄存器</li>
</ul>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ul>
<li>栈是<strong>线程</strong>运行时需要的内存空间</li>
<li>栈的组成元素叫做栈帧，用于存储<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息<ul>
<li>每一个方法的运行所需要的内存就是一个栈帧</li>
<li><strong>局部变量表</strong>存放了编译期可知的各种<code>Java</code>虚拟机基本数据类型（<code>boolean、byte、char、short、int、</code><br>  <code>float、long、double</code>）、对象引用（<code>reference</code>类型，它并不等同于对象本身，可能是一个指向对象起始<br>  地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和<code>returnAddress</code><br>  类型（指向了一条字节码指令的地址），其存储空间是以局部变量槽(<code>Slot</code>)来表示<ul>
<li><code>long</code>和<code>double</code>会占用两个变量槽</li>
<li>其余类型会占用一个变量槽</li>
<li>局部变量表的空间大小（变量槽的数量）在编译器就可以确定</li>
</ul>
</li>
</ul>
</li>
<li>每一个线程只能有一个活动栈帧，对应着当前线程正在执行的那个方法</li>
</ul>
<p>所以方法的代码，局部变量那些都是保存在栈中。</p>
<h3 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h3><h4 id="垃圾回收是否涉及栈内存"><a href="#垃圾回收是否涉及栈内存" class="headerlink" title="垃圾回收是否涉及栈内存"></a>垃圾回收是否涉及栈内存</h4><p>栈内存涉及到的是方法调用，当方法调用完成后方法对应的栈帧就会自动出栈，所以也不存在垃圾回收的问题。</p>
<h4 id="栈内存是否分配的越大越好"><a href="#栈内存是否分配的越大越好" class="headerlink" title="栈内存是否分配的越大越好"></a>栈内存是否分配的越大越好</h4><p>当栈内存分配的越大，也就你意味着能够容纳的栈帧就越多，栈帧越多对应的是方法调用的层级可以更深，但是由于内存总容量是固定的，所以当栈内存越大的时候，同时可以运行的线程的数量就会减少(原因可以看上面栈内存的说明，要知道栈是线程运行时需要的内存空间)</p>
<h4 id="方法内的局部变量是否线程安全"><a href="#方法内的局部变量是否线程安全" class="headerlink" title="方法内的局部变量是否线程安全"></a>方法内的局部变量是否线程安全</h4><p>考虑线程安全的问题需要考虑的一个变量是线程私有的，还是线程共享的，当是线程私有的时候就不会有线程安全的问题，当时线程共享的时候就会有线程安全的问题。</p>
<ul>
<li>如果方法内的局部变量没有逃离方法的作用范围，就是线程安全的</li>
<li>如果局部变量引用了对象，并逃离了方法 的作用范围，就是线程不安全的</li>
</ul>
<h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><ul>
<li>栈帧<strong>过多</strong>会导致栈内存溢出(也就是方法调用层级过多)</li>
<li>栈帧<strong>过大</strong>导致栈内存溢出</li>
<li>栈内存溢出会出现<code>java.lang.StackOverflowError</code>错误</li>
<li>在<code>idea</code>中我们可以自己设置栈的大小来进行测试， 设置参数 为 <code>-Xss256k</code>（<code>-Xss</code>固定，字面的数值自己设置）</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul>
<li>当<code>java</code>虚拟机 调用本地方法的时候需要提供的内存空间</li>
<li>带有<code>native</code>修饰的方法就是本地方法</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>堆内存就是用来存放对象实例的。</strong></p>
<ul>
<li>通过<code>new</code>关键字创建的对象，都会使用堆内存(但是现在已经有技术可以避过这个问题，所以现在这句话也不绝对)</li>
<li>堆是线程共享的，堆中对象都需要考虑线程安全的问题</li>
<li>有垃圾回收机制</li>
</ul>
<h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.heap;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">// -Xmx8m  可以使用-Xmx来修改堆内存大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">"hello"</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200423223432569.png" alt="image-20200423223432569"></p>
<ul>
<li>可以通过 <code>-Xmx8m</code>来将堆内存的大小设置为<code>8m</code>，这样再一次运行循环次数肯定会降低。</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>方法区主要存储的是类结构的，也就是类的一些信息，比如下面的一些信息<ul>
<li>构造方法</li>
<li>成员方法</li>
<li>成员变量</li>
<li>运行时常量池</li>
</ul>
</li>
<li>方法区在虚拟机启动的时候就会创建</li>
<li>方法区在<strong>逻辑上</strong>是堆内存的一部分，但是实际上不一定是，比如对于<code>HotSpot</code>虚拟机在<code>jdk1.8</code>方法区使用<strong>永久代</strong>来实现，确实是堆空间的一部分，但是<code>jdk1.8</code>及以后使用的是<strong>元空间</strong>来实现，使用的是系统内存。</li>
<li>方法区也会导致<code>OutOfMemory</code>错误</li>
</ul>
<p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200423223835220.png" alt="image-20200423223835220"></p>
<h3 id="jdk1-6方法区的内存结构"><a href="#jdk1-6方法区的内存结构" class="headerlink" title="jdk1.6方法区的内存结构"></a>jdk1.6方法区的内存结构</h3><p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200423223943229.png" alt="image-20200423223943229"></p>
<h3 id="jdk1-8方法区的内存结构"><a href="#jdk1-8方法区的内存结构" class="headerlink" title="jdk1.8方法区的内存结构"></a>jdk1.8方法区的内存结构</h3><p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200423224013817.png" alt="image-20200423224013817"></p>
<h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><ul>
<li><p><code>jdk1.8</code>之前会出现永久代内存溢出</p>
<ul>
<li>出现<code>java.lang.OutOfMemoryError:PermGen space</code></li>
<li>可以通过 <code>-XX:MaxPermsize=8m</code>  来设置方法区大小</li>
</ul>
</li>
<li><p><code>jdk1.8</code>之后会导致元空间内存溢出</p>
<ul>
<li>出现<code>java.lang.OutOfMemoryError:Metaspace</code></li>
<li>可以通过<code>-XX:MetaspaceSize=8m</code>来设置方法区大小</li>
</ul>
</li>
</ul>
<h3 id="二进制字节码"><a href="#二进制字节码" class="headerlink" title="二进制字节码"></a>二进制字节码</h3><p>二进制字节码中主要包含了三个内容</p>
<ul>
<li>类的基本信息,比如版本，类的访问修饰符等</li>
<li>常量池</li>
<li>类方法定义(类方法定义中包含了虚拟机指令)</li>
</ul>
<p>可以通过反编译来查看主体是不是包含这三个部分</p>
<p><strong>源代码DemoOne.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对DemoOne.class反编译</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javap -v 类名.class</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200423224155411.png" alt="image-20200423224155411"></p>
<p><strong>反编译后的内容</strong></p>
<p><strong><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200229090947417-1587653003528.png" alt="image-20200229090947417"></strong></p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>从上图可以看出方法定义中包含了<code>jvm</code>指令，<code>jvm</code>指令后可以看到有<code>#1</code>、<code>#2</code>这样的内容，这些就需要到常量池找对应的信息，就可以得知需要执行的是什么代码。</p>
<p><strong>常量池</strong></p>
<blockquote>
<p>常量池就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p>
</blockquote>
<p><strong>运行时常量池</strong></p>
<blockquote>
<p>常量池是二进制字节码（*.class）文件中的,当该类被加载到内存中，它的常量池信息就会放入到运行时常量池中，并且把里面的符号地址转换为真实地址。</p>
</blockquote>
<h4 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h4><p><code>StringTable</code>也就是我们平时所说的串池，当我们定义一个<strong>字符串常量</strong>时，实际上有以下几步：注意这里说的是字符串常量才是这种操作</p>
<ol>
<li>在串池中查找该字符串<ol>
<li>找到了直接返回该字符串</li>
<li>没有找到则创建一个字符串<ol>
<li>将创建的<strong>字符串常量</strong>放入到串池中</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong><code>StringTable</code>的特性</strong></p>
<ul>
<li>常量池中的字符串仅仅是符号，第一次使用时才会变为对象</li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li><strong>字符串变量</strong>的拼接原理是<code>StringBuilder</code>(jdk1.8)</li>
<li><strong>字符串常量</strong>的拼接原理是编译器优化</li>
<li>可以使用<code>intern</code>方法。主动将串池中还没有的字符串对象放入到串池<ul>
<li>对于jdk1.7及以后<ul>
<li><code>intern</code>方法会尝试将这个对象放入串池，如果有则不会放入，如果没有则放入串池，最终会将串池中的对象返回</li>
</ul>
</li>
<li>对于jdK1.6<ul>
<li><code>intern</code>方法会尝试将这个对象放入串池，如果有则不会放入，如果没有则<strong>拷贝一份放入串池</strong>，但是调用的这个对象是不会被放入到串池中，最终会将串池中的对象返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200229095538249.png" alt="案例"></p>
<ul>
<li>上面截图中 <code>String ab1 = a + b</code>在字节码层面实际上是使用的<code>StringBuilder</code>来拼接，最后使用<code>toString</code>方法，实际上是在堆中新建了一个字符串对象</li>
<li><code>String ab2 = &quot;a&quot; + &quot;b&quot;</code>,由于新增的都是常量，所以会在编译器直接拼接中<code>ab</code>,而<code>ab</code>在串池中已经存在，所以<code>ab2</code>这个<code>ab</code>会直接从串池中拿。</li>
</ul>
<h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a><strong>案例2</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableDemo2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">// intern方法会尝试将这个对象放入串池，如果有则不会放入，如果没有则放入串池，最终会将串池中的对象返回</span></span><br><span class="line">        String s2 = s.intern();</span><br><span class="line">        System.out.println(s == <span class="string">"ab"</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s2 == <span class="string">"ab"</span>); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ab = <span class="string">"ab"</span>;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">// intern方法会尝试将这个对象放入串池，如果有则不会放入，如果没有则放入串池，最终会将串池中的对象返回</span></span><br><span class="line">        String s2 = s.intern();</span><br><span class="line">        System.out.println(s == ab); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s2 == ab); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>one方法分析</strong></p>
<ul>
<li><code>new Sring(&quot;a&quot;)</code>实际上有两个操作<ul>
<li>将<code>&quot;a&quot;</code>字符串常量放入到<code>StringTable</code>中</li>
<li>在堆中创建一个字符串对象<code>&quot;a&quot;</code></li>
</ul>
</li>
<li><code>new String(&quot;b&quot;)</code>同样的也是有两个操作<ul>
<li>将<code>&quot;b&quot;</code>字符串常量放入到<code>StringTable</code>中</li>
<li>在堆中创建一个字符串对象<code>&quot;b&quot;</code></li>
</ul>
</li>
<li><code>String s2 = s.intern();</code><ul>
<li><code>s</code>是值为<code>&quot;ab&quot;</code>的字符串对象，该字符串对象存在堆中，<code>StringTable</code>中并没有，所以<code>intern</code>方法会将<code>s</code>指向的对象放入到<code>StringTable</code>中，并且返回<code>StringTable</code>中的对象，因此<code>s</code>和<code>s2</code>都是指向<code>StringTable</code>中<code>&quot;ab&quot;</code>的对象，因此比较的结果都是<code>true</code></li>
</ul>
</li>
</ul>
<p><strong>two方法分析</strong></p>
<ul>
<li><code>two</code>方法与<code>one</code>方法不同之处在于先创建了<code>&quot;ab&quot;</code>字符串常量，所以<code>StringTable</code>中存在<code>&quot;ab&quot;</code>.</li>
<li><code>String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code>这一句和<code>one</code>方法的解析是一样的，<code>s</code>一个指向堆内存中值为<code>&quot;ab&quot;</code>的对象</li>
<li><code>String s2 = s.intern();</code>由于<code>StringTable</code>中已经存在<code>&quot;ab&quot;</code>，所以<code>s</code>对象不会被放入到<code>StringTable</code>中，但是返回的依然是<code>StringTable</code>中的对象，所以比较结果一个是<code>false</code>,一个是<code>true</code></li>
</ul>
<h4 id="StringTable的位置"><a href="#StringTable的位置" class="headerlink" title="StringTable的位置"></a><strong>StringTable的位置</strong></h4><ul>
<li><code>jdk1.6</code>中<code>StringTable</code>存在于永久代中</li>
<li><code>jdk1.8</code>中<code>StringTable</code>存在于堆中</li>
</ul>
<p><strong>验证jdk1.8</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.method;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">// 需要设置堆的大小  -Xmx10m</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableDemo3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200000</span>; j++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                list.add(String.valueOf(j).intern());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于堆空间很大，所以可以设置虚拟机运行参数来控制堆的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx10m</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200229110457271.png" alt></p>
<p>出现<code>GC overhead limit exceeded</code>，此时还需要添加一个参数来关闭这种限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:-UseGCOverheadLimit</span><br></pre></td></tr></table></figure>

<p>此时再去执行会出现如下图所示的错误，可以看到是堆空间不足。</p>
<p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200229111044049.png" alt></p>
<p><strong>验证jdk1.6</strong></p>
<p>首先通过虚拟机参数来控制永久代大小，下面是控制成<code>5m</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:MaxPermSize&#x3D;5m</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200229111447635.png" alt></p>
<p>然后运行上面的代码，可以看到报如下错误</p>
<p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200229111632554.png" alt></p>
<h5 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h5><ul>
<li><code>StringTable</code>底层使用的是<code>HashTable</code>来实现的</li>
<li>如果<code>StringTable</code>中字符串很多，可以通过 <code>-XX:StringTableSize=桶个数</code><ul>
<li>桶个数越大，每一个桶里面装的内容越少，每一个桶里面查找的数据就快，所以我们可以将这个数变大一点</li>
</ul>
</li>
<li>对于需要操作的数据有很多的重复性字符串，那么就可以考虑将这些字符串入池，这样可以减少内存占用</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>在<code>java</code>中调用<code>native</code>方法时实际上执行的部分消耗的内存不是<code>java</code>内存，而是本机的内存，这样当我们调用<code>native</code>方法时其实存在两块内存之间的交互，也就是说当<code>native</code>方法执行完后需要将结果从本地内存复制到<code>java</code>内存中才可以使用，而所谓的直接内存是引入一种<strong>基于通道与缓冲区</strong>的<code>I/O</code>方式，它可以使用<code>native</code>函数库直接分配堆外内存，然后通过一个存储在<code>java</code>堆里面的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作，这样就可以避免在<code>java</code>堆内存和<code>native</code>堆中来回复制数据。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>常见于<code>NIO(NO-Blocking IO)</code>,也就是非阻塞的<code>IO</code>操作，用于数据缓冲区。</li>
<li>分配会回收成本比较高，但是读写性能高</li>
<li>不受<code>JVM</code>内存回收管理</li>
<li>对于直接内存的回收实际上使用的是<code>java</code>中<code>unsafe</code>对象的<code>freeMemory</code>方法来回收而不是通过垃圾回收操作的。</li>
</ul>
<p><strong>java的io操作</strong></p>
<p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200229113833612.png" alt></p>
<ul>
<li>用户操作<code>java</code>程序</li>
<li><code>java</code>程序调用<code>native</code>方法间接调用系统方法操作磁盘中的文件<ul>
<li>系统读取文件时有系统缓冲区</li>
<li><code>java</code>中定义的缓冲区从系统缓冲区中拿出数据</li>
</ul>
</li>
</ul>
<p><strong>使用直接内存操作</strong></p>
<p><img src="/2020/06/06/java/jvm/java%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200229114102103.png" alt></p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的内存布局</title>
    <url>/2020/06/06/java/jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="对象是如何创建出来的"><a href="#对象是如何创建出来的" class="headerlink" title="对象是如何创建出来的"></a>对象是如何创建出来的</h1><p>一个对象的创建肯定主要有以下几步</p>
<ol>
<li>划分内存</li>
<li>将分配的内存空间初始化为0值(不包括对象头)</li>
<li>对对象进行设置，比如将这个对象和类进行关联等</li>
</ol>
<a id="more"></a>

<h2 id="划分内存的方式"><a href="#划分内存的方式" class="headerlink" title="划分内存的方式"></a>划分内存的方式</h2><p>上面说创建对象的第一步就是划分内存，划分内存的主要方式有两种</p>
<ul>
<li>指针碰撞<ul>
<li>假设可用内存都是连接在一起的(也就是一整块的)，那么当需要使用内存空间时只需要将指针移动一下位置就可以划分出一块内存</li>
</ul>
</li>
<li>空闲列表<ul>
<li>如果内存空间不是整齐的，那么剩余的内存肯定是有一张表来记录的，这就是空间列表的模式</li>
</ul>
</li>
</ul>
<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>这里指定是<code>HotSpot</code>虚拟机中的对象的内存布局。</p>
<p>一个对象在堆中包含三个部分</p>
<ul>
<li>对象头<ul>
<li>第一类是用于存储对象自身的运行时数据，如哈希码（<code>HashCode</code>）、<code>GC</code>分代年龄、锁状态标志、线程持有的锁、偏向线程<code>ID</code>、偏向时间戳等。<ul>
<li>在32位和64位的虚拟机中分别是32和64个<code>bit</code></li>
<li>对象头里的信息是与对象自身定义的数据无关的额外存储成本</li>
<li>比如在32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0</li>
</ul>
</li>
<li>对象头的第二部分是存储类型指针，即<strong>对象指向它的类型元数据的指针</strong>。</li>
</ul>
</li>
<li>实例数据</li>
<li>填充的数据</li>
</ul>
<p><img src="/2020/06/06/java/jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/image-20200426080215086.png" alt="image-20200426080215086"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载器</title>
    <url>/2020/06/06/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><ul>
<li><p>将<code>java</code>源代码经过编译器编译器<code>class</code>字节码文件</p>
<ul>
<li><code>java</code>文件和<code>class</code>文件都是在本次磁盘中</li>
</ul>
</li>
<li><p>将字节码文件加载进内存，并且在内存中创建对象的<code>class</code>对象，这个过程称之为类的加载</p>
<p>  一个类的生命周期从类被加载、连接和初始化开始，只有在虚拟机内存中，我们的<code>java</code>程序才可以使用它。</p>
</li>
</ul>
<p><img src="/2020/06/06/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301102806401.png" alt="image-20200301102806401"></p>
<a id="more"></a>

<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类的加载是由类加载器完成的，类加载器可以分为两种</p>
<ul>
<li>第一种是<code>java</code>虚拟机自带的类加载器<ul>
<li>根类加载器(<code>Bootstrap</code>)</li>
<li>扩展类加载器(<code>Extension</code>)</li>
<li>系统了加载器</li>
</ul>
</li>
<li>第二种是用户自定义的类加载器<ul>
<li>自定义类加载器是<code>java.lang.ClassLoader</code>的子类实例</li>
</ul>
</li>
</ul>
<p><img src="/2020/06/06/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301095942835.png" alt="image-20200301095942835"></p>
<h2 id="根类加载器"><a href="#根类加载器" class="headerlink" title="根类加载器"></a>根类加载器</h2><ul>
<li>根类加载器是最底层的类加载器，是虚拟机的一部分，没有父类，也没有继承<code>java.lang.ClassLoader</code></li>
<li>主要负责<code>&lt;JAVA_HOME&gt;/jre/lib</code>下的核心类库</li>
<li>处于安全考虑，根类加载器只能加载<code>java</code>、<code>javax</code>、<code>sun</code>开头的类</li>
</ul>
<h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h2><ul>
<li>扩展类加载器是指由原<code>SUN</code>公司实现的<code>sun.misc.Launcher</code>类</li>
<li>该类加载器是由<code>java</code>语言编写，父类加载器是根类加载器</li>
<li>负责加载<code>&lt;JAVA_HOME&gt;/jre/lib/ext</code>目录下的类库或者系统变量<code>“java.ext.dirs”</code>指定的目录下的类库。</li>
</ul>
<h2 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h2><ul>
<li>系统类加载器也称之为应用类加载器，也是纯<code>java</code>类</li>
<li>系统类加载器的父类加载器是扩展类加载器</li>
<li>负责加载<code>classpath</code>环境变量或系统属性<code>java.class.path</code>所指定的目录中加载类</li>
<li>应用类加载器是用户自定义的类加载器的默认父加载器，一般情形下，该类加载器是程序中默认的类加载器，可以通过<code>ClassLoader.getSystemClassLoader()</code>直接获取</li>
</ul>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><ul>
<li>除了虚拟机自带的根类加载器之外，其余的类家在重庆都有自己唯一的父加载器</li>
<li>当需要使用类加载器加载一个类时，该<code>classLoder</code>会先委托自己的父家在重庆去加载这个类，如果父类加载器可以加载，则由父类加载器去加载。否则才是<code>classLoader</code>自己去加载这个类</li>
<li>双亲委派机制的父子关系和面向对象程序设计中的继承关系是不一样的，而是通过使用组合模式来复用父类加载器。</li>
</ul>
<p><img src="/2020/06/06/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301111621578.png" alt="image-20200301111621578"></p>
<h2 id="双亲委派模式的好处"><a href="#双亲委派模式的好处" class="headerlink" title="双亲委派模式的好处"></a>双亲委派模式的好处</h2><ul>
<li>可以避免类的重复加载，当父类加载器已经加载了该类时，就没有必要让子<code>ClassLoader</code>再去加载一次</li>
<li>考虑到安全因素，<code>java</code>核心<code>api</code>中定义的类型不会被随意替换<ul>
<li>比如自己定义了一个<code>java.lang.Object</code>的类，通过双亲委托模式传递到启动类加载器，启动类加载器在核心<code>api</code>中发现了这个名字的类，发现已经被加载，这样就不会重新加载，而是直接返回已经加载过的<code>Object.class</code>，这样就可以防止核心<code>api</code>被随意篡改。</li>
</ul>
</li>
</ul>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码的包名是<code>java.lang</code>，由于<code>java</code>的核心<code>api</code>的包名也是这个，所以运行上面的成出现下面的错误</p>
<p><img src="/2020/06/06/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301112618193.png" alt="image-20200301112618193"></p>
<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><p><code>ClassLoader</code>中主要看这个方法</p>
<h2 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先检查该类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">          <span class="comment">// 还没加载的类才会继续加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果有父类加载器就让父类去加载</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// 没有父类就使用根类加载器去加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">               		<span class="comment">// 如果父类加载器或根类加载器都没有加载到，就使用自己的类加载器去加载</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name)</span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>laodClass</code>方法中体现了双亲委托模式的逻辑<ul>
<li>首先让父类加载器加载</li>
<li>父类加载器没有加载到就让根类加载器加载</li>
<li>父类或根类加载器都没有加载到的时候就使用自己的类加载器加载</li>
</ul>
</li>
</ul>
<h2 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>findClass</code>默认是一个错误的空实现，<strong>这也是我们自定义类加载器时需要重写的方法。</strong></p>
<h2 id="defineCLass"><a href="#defineCLass" class="headerlink" title="defineCLass"></a>defineCLass</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                         ProtectionDomain protectionDomain)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是用来将<code>byte[]</code>字节解析成虚拟机能够识别的<code>class</code>对象，<code>defineClass</code>通常和<code>findClass</code>方法一起使用，在自定义类加载器时，会直接覆盖<code>CLassLoader</code>的<code>findCLass</code>方法获取想要加载类的字节码，然后调用<code>defineCLass</code>方法生成<code>Class</code>对象。</p>
<h2 id="resolveCLass"><a href="#resolveCLass" class="headerlink" title="resolveCLass"></a>resolveCLass</h2><p>连接指定的类，类加载器可以使用此方法来连接类。</p>
<h1 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h1><p>在<code>java.net</code>包中。<code>jdk</code>提供了一个类加载器<code>URLClassLoader</code>，该类扩展了<code>ClassLoader</code>，能够从本地或网络</p>
<p>上指定的位置加载类，我们也可以使用该类作为自定义的类加载器使用。</p>
<p>其构造器中只要需要传入<code>URL</code>地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls)</span> </span>&#123;&#125;<span class="comment">// 使用默认的父类构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent)</span> </span>&#123;&#125; <span class="comment">// 也可以自己指定构造器</span></span><br></pre></td></tr></table></figure>



<p><strong>测试案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.loader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestURLClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载本地的类</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOne</span> <span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"d:/"</span>);</span><br><span class="line">        URI uri = file.toURI();</span><br><span class="line">        URL url = uri.toURL();</span><br><span class="line">        URLClassLoader urlClassLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        Class&lt;?&gt; aClass = urlClassLoader.loadClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        aClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载网络上的类</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTwo</span> <span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost:8080/examples/"</span>);</span><br><span class="line">        URLClassLoader urlClassLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        Class&lt;?&gt; aClass = urlClassLoader.loadClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        aClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加载本地的类</strong></p>
<p>在我的本地<code>d</code>盘根目录中有一个 <code>TestClassLoader.java</code>文件，文件内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoader</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestClassLoader</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"new Instance"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时使用<code>javac</code>命令来编译一下：</p>
<p><code>javac -d . TestClassLoader.java</code></p>
<p><img src="/2020/06/06/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301131544718.png" alt="image-20200301131544718"></p>
<p><img src="/2020/06/06/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301131633046.png" alt="image-20200301131633046"></p>
<ul>
<li><code>-d</code>选项是指定编译到哪里去的位置</li>
<li><code>.</code>点是指当前目录</li>
</ul>
<p>执行加载本地的类的代码会输出  <code>new Instance</code></p>
<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>上面已经说过，想要自定义类加载器，有如下几个固定步骤</p>
<ul>
<li>自定义的类需要继承<code>ClassLoader</code>抽象类</li>
<li>重写<code>findCLass</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.loader;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被加载的类所在的目录</span></span><br><span class="line">    <span class="keyword">private</span> String directory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义类加载器需要重写该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//    将类名转换为目录</span></span><br><span class="line">            String file = directory + File.separator + name.replace(<span class="string">"."</span>, File.separator) + <span class="string">".class"</span>;</span><br><span class="line">            <span class="comment">// 构建输入流</span></span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">// 构建字节输出流</span></span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="comment">// 定义缓冲区</span></span><br><span class="line">            <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 往输出流中输入数据</span></span><br><span class="line">                baos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//读取到的字节码二进制数据</span></span><br><span class="line">            <span class="keyword">byte</span> data[] = baos.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// main方法测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"d:/"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = myClassLoader.loadClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        System.out.println(aClass.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="热部署类加载器"><a href="#热部署类加载器" class="headerlink" title="热部署类加载器"></a>热部署类加载器</h1><p><strong>所谓的热部署就是让同一个<code>class</code>可以被不同的类加载器加载即可。</strong></p>
<p>当我们使用<code>loadClass</code>方法加载类时，会采用双亲委托模式。</p>
<ul>
<li>如果一个类已经被加载，加一次加载该类时就会从缓存中取，不会重新加载</li>
<li>如果同一个<code>class</code>被同一个类加载器加载多次，则会报错</li>
</ul>
<p>而<code>ClassLoader</code>中实现委托机制的代码主要在<code>loadClass</code>方法，而真正实现加载的则是<code>findClass</code>方法，所以我们只需要不调用<code>loadClass</code>方法而直接调用<code>findClass</code>就可以实现同一个类被不同的类加载器加载。</p>
<p><strong>案例代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.loader;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"D:/"</span>);</span><br><span class="line">        MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(classLoader,<span class="string">"D:/"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass1 = classLoader1.loadClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        System.out.println(aClass.hashCode()); <span class="comment">// 1364335809</span></span><br><span class="line">        System.out.println(aClass1.hashCode());<span class="comment">// 1364335809</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"D:/"</span>);</span><br><span class="line">        MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(classLoader,<span class="string">"D:/"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = classLoader.findClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass1 = classLoader1.findClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        System.out.println(aClass.hashCode()); <span class="comment">// 233530418</span></span><br><span class="line">        System.out.println(aClass1.hashCode()); <span class="comment">// 683287027</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了上面自定义类加载器的代码。</p>
<ul>
<li>第一个测试案例中两个<code>class</code>的<code>hashCode</code>是一致的，说明类加载器的双亲委托机制起了作用</li>
<li>第二个测试案例中虽然第一个类加载器也是第二类加载器的父类加载器，但是两个类的<code>hashCode</code>并不是一样的，这说明，这两个类加载器都起了作用，这是因为这里没有使用<code>loadClass</code>方法，所以双亲委托机制的代码就没有起到作用。</li>
</ul>
<h1 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h1><p>对于使用<code>JDBC</code>的时候我们都知道，第一步就是要注册驱动,对于<code>mysql</code>而言如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/06/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301142454190.png" alt="image-20200301142454190"></p>
<p>但是实际上即使我们没有写这样的一句代码，其余的代码也是可以正常执行的。那来看一下<code>DriverManager</code>类的代码：</p>
<p><img src="/2020/06/06/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301143318867.png" alt="image-20200301143318867"></p>
<p>在第2步里面有两种方式来注册该驱动</p>
<p><strong>来看2.1中实现类加载的方式</strong></p>
<p><code>2.1</code>的代码跟到第4步的时候可以看到下面这样的一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>Thread.currentThread().getContextClassLoader()</code>，也就是获取<strong>线程上下文类类加载器</strong>，在线程启动的时候应用类加载器会默认赋值给当前线程，所以<code>getContextClassLoader</code>方法默认情况下获取的也是应用类加载器。</p>
<p><strong>看2.2的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">"DriverManager.Initialize: loading "</span> + aDriver);</span><br><span class="line">                Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                        ClassLoader.getSystemClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                println(<span class="string">"DriverManager.Initialize: load failed: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里面使用到了<code>Class.forName(aDriver, true,  ClassLoader.getSystemClassLoader())</code></p>
<p>对于<code>ClassLoader.getSystemClassLoader()</code>方法获取的是<strong>系统应用类加载器</strong>，所以这里其实是破坏了双亲委托模式，因为<code>DriverManager</code>是启动项加载器来加载的(也就是根类加载器)，而在<code>DriverManager</code>中使用系统类加载器去加载数据库驱动包的类。</p>
<p>还有一个点需要注意，在2.2代码中使用到了<code>aDriver</code>这个变量，该变量来源</p>
<p><img src="/2020/06/06/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301144304571.png" alt="image-20200301144304571"></p>
<p>也就是从<code>jdbc.drivers</code>文件中去加载，其余这里是使用到了<code>SPI</code>机制</p>
<h2 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h2><blockquote>
<p><code>SPI</code> ，全称为 <code>Service Provider Interface</code>，是一种服务发现机制。它通过在<code>ClassPath</code>路径下的<code>META-INF/services</code>文件夹查找文件，自动加载文件里所定义的类.</p>
</blockquote>
<p>可以看一下<code>Mysql</code>驱动包里面确实有有这样的一个文件</p>
<p><img src="/2020/06/06/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301144534613.png" alt="image-20200301144534613"></p>
<p>对于使用<code>SPI</code>机制使用到的类是  <code>ServiceLoader</code>。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载过程</title>
    <url>/2020/06/06/java/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制</p>
</blockquote>
<a id="more"></a>

<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止会经历如下几个过程。</p>
<ul>
<li>加载</li>
<li>验证</li>
<li>准备</li>
<li>解析</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ul>
<p><font color="red">需要注意的是<strong>加载-&gt;验证-&gt;准备-&gt;初始化-&gt;卸载</strong>这五个操作的顺序是固定的，但是解析操作可以在初始化之前也可以在初始化之后，比如对于动态代理技术就是解析操作在初始化之后实现的</font></p>
<p><img src="/2020/06/06/java/jvm/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-20200426220535068.png" alt="image-20200426220535068"></p>
<p>如上图所示，验证，准备和解析三个阶段合起来叫做<strong>连接</strong>阶段。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p><font color="red">需要注意的是<strong>加载</strong>和<strong>类加载</strong>这两个概念，<strong>加载</strong>是<strong>类加载</strong>的第一个阶段</font></p>
<p>在加载阶段，虚拟机需要完成三件事</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证目的是确保<code>Class</code>文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>验证包含以下几个部分</p>
<h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>验证字节流是否符合<code>Class</code>文件格式的规范，并且能被当前版本的虚拟机处理。</p>
<h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p>对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。主要包含以下几点：</p>
<ul>
<li>除了<code>Object</code>类外应该都有父类</li>
<li>这个类的父类是否继承了不允许被继承的类（被<code>final</code>修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>。。。</li>
</ul>
<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（<code>Class</code>文件中的<code>Code</code>属性）进行校验分析，保证被校验类的方法在运行时不会做出危害<br>虚拟机安全的行为。</p>
<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类中定义的变量（即静态变量，被<code>static</code>修饰的变量）分配内存并设置类变量<strong>初始值</strong>的阶段。</p>
<p>需要注意上面所示的初始值是指变量的默认值。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">（short）0</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘\u0000’</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">（byte）0</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">reference</td>
<td align="center">null</td>
</tr>
</tbody></table>
<p><font color="red">如果是定义成final类型，那么准备阶段的赋值就不不是默认值了，而是我们给的是什么值就是什么值</font></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是<code>Java</code>虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>解析动作主要针对以下七种类型进行解析</p>
<ol>
<li>类或接口</li>
<li>字段</li>
<li>类方法</li>
<li>接口方法</li>
<li>方法类型</li>
<li>方法句柄</li>
<li>调用点限定符</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>之前介绍的几个类加载的动作里，除了在<strong>加载</strong>阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由<code>Java</code>虚拟机来主导控制。直到初始化阶段，<code>Java</code>虚拟机才真正开始执行类中编写的<code>Java</code>程序代码。</p>
<h3 id="什么时候会初始化"><a href="#什么时候会初始化" class="headerlink" title="什么时候会初始化"></a>什么时候会初始化</h3><p>当执行下面的操作的时候如果一个类还没有执行初始化的操作，则需要先初始化</p>
<ul>
<li>使用<code>new</code>关键字<code>new</code>一个对象</li>
<li>读取或设置一个类型的静态字段，但是如果是<code>final</code>类型的除外</li>
<li>调用一个类型的静态方法</li>
<li>使用<code>java.lang.reflect</code>包的方法对一个类型进行反射调用的时候</li>
<li>当初始化的时候，如果一个父类还没有初始化，则需要先初始化父类</li>
<li>虚拟机启动时，会先初始化主类(<code>main</code>方法所在的类)</li>
<li>当一个接口中定义了<code>JDK 8</code>新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理和使用jdk自带的HSDB查看被代理的类的代码</title>
    <url>/2020/06/06/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://gitee.com/Gwei11/code/tree/master/javabase/proxy/proxy-demo" target="_blank" rel="noopener">动态代理示例代码</a></p>
<h1 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h1><p>所谓的代理模式简单理解就是对原有的功能增强的一种模式。代理模式有三个角色：    </p>
<ul>
<li>接口(<code>Subject</code>)   </li>
<li>委托类(<code>RealSubject</code>),该类也是真正实现功能的类    </li>
<li>代理类(<code>ProxySubject</code>)这个代理类对我们的委托类进行增强处理 </li>
</ul>
<a id="more"></a>

<h1 id="动态代理分类"><a href="#动态代理分类" class="headerlink" title="动态代理分类"></a>动态代理分类</h1><h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p><code>jdk</code>动态代理的的核心是主要是有两个类</p>
<ul>
<li><code>Proxy</code>类的<code>newProxyInstance</code>方法</li>
<li><code>InvocationHandler</code> 接口</li>
</ul>
<h3 id="jdk动态代理案例"><a href="#jdk动态代理案例" class="headerlink" title="jdk动态代理案例"></a><code>jdk</code>动态代理案例</h3><ul>
<li>一个接口</li>
<li>该接口的实现类</li>
<li>一个实现了<code>InvocationHandler</code> 接口的处理类</li>
</ul>
<p><strong>接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dynamicProxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NeedProxyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dynamicProxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedProxyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">NeedProxyInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现了<code>InvocationHandler</code> 接口的处理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dynamicProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    NeedProxyInterface needProxyInterface = <span class="keyword">new</span> NeedProxyInterfaceImpl();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">111</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(needProxyInterface, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dynamicProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NeedProxyInterface object =</span><br><span class="line">               (NeedProxyInterface)Proxy.newProxyInstance(NeedProxyInterface<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                new Class[]&#123;NeedProxyInterface.class&#125;, new MyInvocationHandler());</span><br><span class="line">        object.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以根据下面介绍的使用方式使用<code>HSDL</code>工具生成代理类文件，生成的文件内容如下：</p>
<p><strong>代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dynamicProxy.NeedProxyInterface;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">NeedProxyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m4 = Class.forName(<span class="string">"com.dynamicProxy.NeedProxyInterface"</span>).getMethod(<span class="string">"sayHello"</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.dynamicProxy.NeedProxyInterface"</span>).getMethod(<span class="string">"add"</span>, Integer.TYPE, Integer.TYPE);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="/2020/06/06/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422211307163.png" alt="image-20200422211307163"></p>
<p>其实我们之所以不懂代理，是因为这个代理类生成后是在内存中的，如果我们能看到这样的一个类的代码就不会觉得难，所以可以使用上面所说的<code>HSDL</code>工具将代理类下载下来就比较容易看懂。</p>
<h1 id="使用HSDL工具查看代理类代码"><a href="#使用HSDL工具查看代理类代码" class="headerlink" title="使用HSDL工具查看代理类代码"></a>使用HSDL工具查看代理类代码</h1><h2 id="找到jdk当中的sa-jdi-jar的位置"><a href="#找到jdk当中的sa-jdi-jar的位置" class="headerlink" title="找到jdk当中的sa-jdi.jar的位置"></a>找到<code>jdk</code>当中的<code>sa-jdi.jar</code>的位置</h2><p>比如在我的电脑上这个<code>jar</code>包的位置</p>
<p><img src="/2020/06/06/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422210719406.png" alt="image-20200422210719406"></p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>执行如下所示的命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\&gt;java -classpath <span class="string">"D:\installpackage\programme\java\jdk1.8\lib\sa-jdi.jar"</span> sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure>

<p>执行完成之后会出现一个窗口</p>
<p><img src="/2020/06/06/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422210835780.png" alt="image-20200422210835780"></p>
<h2 id="运行jsp命令找到进程ID"><a href="#运行jsp命令找到进程ID" class="headerlink" title="运行jsp命令找到进程ID"></a>运行jsp命令找到进程ID</h2><p><img src="/2020/06/06/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422210909216.png" alt="image-20200422210909216"></p>
<p>将这里找到的进程ID输入到上面第一步的位置，然后进行如下截图所示操作：</p>
<p><img src="/2020/06/06/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422210922005.png" alt="image-20200422210922005"></p>
<p><img src="/2020/06/06/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422210937056.png" alt="image-20200422210937056"></p>
<p>如上图所示，因为案例中<code>cglib</code>代理的是<code>Producer</code>，所以这里我们搜索<code>Producer</code>，可以看到下面有一个类就是<code>Producer</code>，还有一个是<code>cglib</code>的代理类，我们点击那个<code>cglib</code>的代理类</p>
<p><img src="/2020/06/06/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422211017916.png" alt="image-20200422211017916"></p>
<p>点击之后会出现上图所示界面，点击<code>create.class file</code>即可</p>
<p><img src="/2020/06/06/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422211044414.png" alt="image-20200422211044414"></p>
<p>我们可以根据这个代理类的名称来找到生成的这个代理类在哪里（<strong>默认的位置和我们运行cmd的路径有关，比如上面我是在D盘根目录中运行的cmd命令，所以创建的代理类的位置就是在D盘根目录然后加上这个类的包路径</strong>）。</p>
<h1 id="直接使用jdk累生成代理类代码"><a href="#直接使用jdk累生成代理类代码" class="headerlink" title="直接使用jdk累生成代理类代码"></a>直接使用jdk累生成代理类代码</h1><p>还有一种方式可以直接使用<code>jdk</code>生成类的方式来生成代理类并且使用输出流输出到本地，然后使用反编译工具来查看即可。比如还是上面的那个接口，现在想要生成代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = ProxyGenerator.generateProxyClass(<span class="string">"$Proxy0"</span>, <span class="keyword">new</span> Class[]&#123;NeedProxyInterface<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">FileOutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"D://$Proxy0.class"</span>);</span><br><span class="line">os.write(bytes);</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure>

<p>这样就可以在D盘看到<code>$Proxy0.class</code>文件，<code>$Proxy0</code>这个是我们自己取的代理类的名字。</p>
<p>再使用反编译工具查看发现和我们使用<code>HSDL</code>查看的工具类时一样的。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射</title>
    <url>/2020/06/06/java/%E5%8F%8D%E5%B0%84/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><p>将类的各个组成部分封装成其他的对象，就是反射机制</p>
<p><a href="https://gitee.com/Gwei11/Java/tree/master/code/java-base/reflect" target="_blank" rel="noopener">示例代码地址</a></p>
<h1 id="java代码在计算机中经历的三个阶段"><a href="#java代码在计算机中经历的三个阶段" class="headerlink" title="java代码在计算机中经历的三个阶段"></a>java代码在计算机中经历的三个阶段</h1><p><img src="/2020/06/06/java/%E5%8F%8D%E5%B0%84/%E5%8F%8D%E5%B0%84/image-20200227081551928.png" alt="image-20200227081551928"></p>
<a id="more"></a>

<h2 id="source源代码阶段"><a href="#source源代码阶段" class="headerlink" title="source源代码阶段"></a>source源代码阶段</h2><ul>
<li>我们编写的都是<code>.java</code>文件</li>
<li>经过<code>java</code>编译器编译后编程了<code>.class</code>文件，<code>.java</code>和 <code>.class</code>都是在计算机硬盘中的文件</li>
</ul>
<h2 id="Class类对象阶段"><a href="#Class类对象阶段" class="headerlink" title="Class类对象阶段"></a>Class类对象阶段</h2><ul>
<li><code>.class</code>可以文件可以经过类加载器加载进内存，并且在内存中创建一个<code>Class</code>类对象来表示这个 <code>.class</code>文件的一些共有的特性</li>
<li><code>.class</code>字节码文件中含有<strong>成员变量</strong>、<strong>构造方法</strong>以及<strong>成员方法</strong>，而且每一种可能有多个，所以将 每一种类型的数据都定义了一种类型来对应，并且在<code>Class</code>类对象中使用对应的数组来存储<ul>
<li>成员变量——&gt;<code>Filed</code></li>
<li>构造方法——-&gt;<code>Constructor</code></li>
<li>成员方法——–&gt;<code>Method</code></li>
</ul>
</li>
</ul>
<h2 id="Runtime运行时阶段"><a href="#Runtime运行时阶段" class="headerlink" title="Runtime运行时阶段"></a>Runtime运行时阶段</h2><p>在内存中使用<code>Class</code>类对象来表示一个字节码文件后，我们就可以使用这个 <code>Class</code>类对象来创建对象，这就是<strong>运行时状态</strong>表现出来的。</p>
<h1 id="获取Class类对象"><a href="#获取Class类对象" class="headerlink" title="获取Class类对象"></a>获取Class类对象</h1><p>从上面的图可以 知道，要想使用反射，首先要获取的就是<code>Class</code>类对象，而<code>java</code>代码在计算机中三个阶段，在每一个阶段都有对应的获取方式。</p>
<h2 id="Class-forName（源代码阶段）"><a href="#Class-forName（源代码阶段）" class="headerlink" title="Class.forName（源代码阶段）"></a>Class.forName（源代码阶段）</h2><p>在源代码阶段，<code>class</code>字节码文件还是在硬盘中，没有被加载进内存，所以此时想要获取<code>Class</code>类对象，可以通过<code>Class.forName(&quot;完整类路径&quot;)</code>方式获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.classobject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 第二种方式</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">"example.classobject.ClassObject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类名-class（Class类对象阶段）"><a href="#类名-class（Class类对象阶段）" class="headerlink" title="类名.class（Class类对象阶段）"></a>类名.class（Class类对象阶段）</h2><p>如果是已经加载进入内存了，那么就可以通过<code>类名.class</code>属性来获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.classobject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种方式</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">"example.classobject.ClassObject"</span>);</span><br><span class="line">        <span class="comment">// 第二种方式</span></span><br><span class="line">        Class&lt;ClassObject&gt; testOneClass = ClassObject<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(aClass == testOneClass); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象-getClass（运行时阶段）"><a href="#对象-getClass（运行时阶段）" class="headerlink" title="对象.getClass（运行时阶段）"></a>对象.getClass（运行时阶段）</h2><p>如果已经有了对象，那么就可以通过<code>对象.getClass</code>获取 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.classobject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种方式</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">"example.classobject.ClassObject"</span>);</span><br><span class="line">      	<span class="comment">// 第二种方式</span></span><br><span class="line">        Class&lt;ClassObject&gt; testOneClass = ClassObject<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(aClass == testOneClass); <span class="comment">// true</span></span><br><span class="line">        <span class="comment">// 第三种方式</span></span><br><span class="line">        ClassObject classObject = <span class="keyword">new</span> ClassObject();</span><br><span class="line">        Class&lt;? extends ClassObject&gt; aClass1 = classObject.getClass();</span><br><span class="line">        System.out.println(aClass1 == aClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Class对象的功能"><a href="#Class对象的功能" class="headerlink" title="Class对象的功能"></a>Class对象的功能</h1><p>上面给出了三种获取<code>Class</code>对象的方法，既然已经获取了<code>Class</code>对象，那么接下来的就是要使用<code>Class</code>对象了，下面列举的是<code>Class</code>对象常用的一些方法。</p>
<p>下面的三组方法都有分为带有<code>Declared</code>的和不带有的，区别在于：</p>
<ul>
<li>带有<code>Declared</code>可以不用考虑修饰符权限问题</li>
<li>不带有<code>Declared</code>只能操作<code>public</code>修饰符修饰的内容</li>
</ul>
<h2 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h2><p>带有<code>Declared</code>的，不考虑修饰符所有的成员变量都可以获取</p>
<p><img src="/2020/06/06/java/%E5%8F%8D%E5%B0%84/%E5%8F%8D%E5%B0%84/image-20200227130457801.png" alt="image-20200227130457801"></p>
<p>不带<code>Declared</code>的，字段修饰符必须是<code>public</code>的才能获取</p>
<p><img src="/2020/06/06/java/%E5%8F%8D%E5%B0%84/%E5%8F%8D%E5%B0%84/image-20200227130534158.png" alt="image-20200227130534158"></p>
<h3 id="成员变量的作用"><a href="#成员变量的作用" class="headerlink" title="成员变量的作用"></a>成员变量的作用</h3><p>上面的四个方法是获取成员变量，那我们获取了成员变量之后一般都是有两个操作</p>
<ul>
<li><p>设置值（下面只是列举一个方法，其余方法可以查看<code>api</code>）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取值</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h2><p><img src="/2020/06/06/java/%E5%8F%8D%E5%B0%84/%E5%8F%8D%E5%B0%84/image-20200227130639294.png" alt="image-20200227130639294"></p>
<p><img src="/2020/06/06/java/%E5%8F%8D%E5%B0%84/%E5%8F%8D%E5%B0%84/image-20200227130713176.png" alt="image-20200227130713176"></p>
<h3 id="构造方法的作用"><a href="#构造方法的作用" class="headerlink" title="构造方法的作用"></a>构造方法的作用</h3><p>构造器的主要作用就是为了<strong>创建对象</strong>，主要是使用<code>Constructor</code>对象的<code>newInstance</code>方法，具体用法看上面给的案例地址。</p>
<h2 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h2><p><img src="/2020/06/06/java/%E5%8F%8D%E5%B0%84/%E5%8F%8D%E5%B0%84/image-20200227130754772.png" alt="image-20200227130754772"></p>
<p><img src="/2020/06/06/java/%E5%8F%8D%E5%B0%84/%E5%8F%8D%E5%B0%84/image-20200227130833356.png" alt="image-20200227130833356"></p>
<h3 id="成员方法的作用"><a href="#成员方法的作用" class="headerlink" title="成员方法的作用"></a>成员方法的作用</h3><p>上面的几个方法是为了获取成员方法，获取成员方法的作用其实就是为了<strong>可以执行方法</strong>，此时需要使用<code>Method</code>类中的<code>invoke</code>方法，该方法第一个参数是一个实际需要执行的对象，第二个参数是一个可变参数列表。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>join方法详解</title>
    <url>/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/join%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="join的使用"><a href="#join的使用" class="headerlink" title="join的使用"></a>join的使用</h1><h2 id="正常情形"><a href="#正常情形" class="headerlink" title="正常情形"></a>正常情形</h2><p><code>join</code>的目的是让调用线程等待被调用的线程执行完成之后再继续。</p>
<ul>
<li>对于<code>join</code>方法需要注意的是谁等待谁<ul>
<li>调用<code>join</code>方法所在的线程需要等待调用<code>join</code>方法的对象线程执行完毕</li>
</ul>
</li>
<li>下面代码案例中<code>thread.join()</code>和<code>thread2.join()</code>都是在<code>main</code>线程中调用的，所以是<code>main</code>线程要等其他线程，那么这里的其他线程是哪个线程呢？就是调用<code>join</code>的<code>thread</code>和<code>thread2</code>线程</li>
</ul>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JoinDemo joinDemo = <span class="keyword">new</span> JoinDemo();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(joinDemo);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(joinDemo);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"子线程都执行完了"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是正常的情形，也就是说<code>main</code>线程确实是等到另外两个线程执行完毕之后才执行的。</p>
<h2 id="中断情形"><a href="#中断情形" class="headerlink" title="中断情形"></a>中断情形</h2><p>下面演示的是在子线程中中断了主线程，这样虽然主线程中调用了子线程的<code>join</code>方法，但是也有可能是主线程先执行完。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemoInterrupt</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取主线程的引用</span></span><br><span class="line">        Thread threadMain = Thread.currentThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 中断主线程</span></span><br><span class="line">                threadMain.interrupt();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"子线程都执行完了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/join%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20200505111440561.png" alt="image-20200505111440561"></p>
<p>从上面截图可以看到实际上是主线程先执行完的。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>上面中断的情形显然是不对，那么应该如何解决呢？其实在主线程被中断之后，应该通知子线程，通知子线程的方式就是中断子线程。所以代码也很简单，就是在上面的点啊基础上加一行代码即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testjoin;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemoInterrupt</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取主线程的引用</span></span><br><span class="line">        Thread threadMain = Thread.currentThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 中断主线程</span></span><br><span class="line">                threadMain.interrupt();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 中断子线程</span></span><br><span class="line">            thread.interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"子线程都执行完了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就加一一句<code>thread.interrupt();</code>这是中断子线程，但是需要注意的是不代表加上这一句话之后，子线程一定会先执行完。因为当调用<code>join</code>的线程被中断之后实际上是已经不会继续等其他线程执行完了。</p>
<h1 id="join的原理"><a href="#join的原理" class="headerlink" title="join的原理"></a>join的原理</h1><p>我们来看一下<code>join</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面是<code>join</code>方法的源码，可以看出来实际上底层调用的就是<code>wait</code>，但是我们调用<code>wait</code>的时候是需要<code>notify</code>或者<code>notifyAll</code>方法来唤醒的，但是这里没有看到任何的<code>notify</code>方法的身影啊。其实这是因为每一个线程执行完成之后都会调用当前线程的<code>notify</code>方法。这是线程底层做的事情。</p>
<h1 id="join的替代方式"><a href="#join的替代方式" class="headerlink" title="join的替代方式"></a>join的替代方式</h1><p>上面说每一个线程执行完成后都会调用当前线程的<code>notify</code>方法，那么我们是不是就可以使用<code>wait</code>方法来替换<code>join</code>方法呢？请看下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testjoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemoInterrupt</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取主线程的引用</span></span><br><span class="line">        Thread threadMain = Thread.currentThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//thread.join();</span></span><br><span class="line">            <span class="keyword">synchronized</span> (thread) &#123;</span><br><span class="line">                thread.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"子线程都执行完了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果和正常情形的执行结果是一样的。我们所做的就是将<code>thread.join()</code>方法替换为了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (thread) &#123;</span><br><span class="line">  thread.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里使用了<code>synchronized</code>是因为<code>wait</code>方法必须在同步代码块中使用</li>
<li>这里的锁对象<code>thread</code>就是子线程的名称，这里需要注意的是替换后要想达到一样的效果这里的锁对象就必须是被等待线程的引用，因为上面说每一个线程执行完成后都会调用当前线程的<code>notify</code>方法，<code>wait</code>和<code>notify</code>必须是在同一个锁上面才会生效。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字的用法</title>
    <url>/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized/</url>
    <content><![CDATA[<p>对于<code>synchronized</code>我们都知道是同步代码的作用，使用了<code>synchronized</code>关键字后，就是对其修饰的方法或代码块进行加锁，这样就能保证同一时间只能有一个线程访问到被其修饰的方法或代码块。</p>
<p><code>synchronized</code>可以修饰的情形有以下几种</p>
<ul>
<li>静态方法</li>
<li>成员方法</li>
<li>代码块</li>
</ul>
<a id="more"></a>

<h1 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h1><p>假设现在有一个静态方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testStaticMehotd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2L</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" is runing"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException var1) &#123;</span><br><span class="line">    var1.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>javap</code>命令将这个类反编译后看一下这个方法的二进制命令</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized/image-20200425221815727.png" alt="image-20200425221815727"></p>
<h1 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCodeBlockTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Class var1 = SynchronizedTwo<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  <span class="keyword">synchronized</span>(SynchronizedTwo<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">2L</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" is runing"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException var4) &#123;</span><br><span class="line">      var4.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样使用<code>javap</code>命令来反编译看一下</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized/image-20200425222256643.png" alt="image-20200425222256643"></p>
<h1 id="对方法和代码块加锁的不同机制"><a href="#对方法和代码块加锁的不同机制" class="headerlink" title="对方法和代码块加锁的不同机制"></a>对方法和代码块加锁的不同机制</h1><p>其实经过上面两个截图能说看，<code>synchronized</code>对方法加锁和对代码块就锁的机制是不同的。</p>
<ul>
<li>对代码块使用<code>synchronized</code>加锁是使用了<code>Monitorenter</code>和<code>Monitorexit</code>指令来实现的</li>
<li>对方法加锁使用<code>ACC_SYNCHRONIZED</code>标识符来实现的</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>启动线程的正确和错误方式</title>
    <url>/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%92%8C%E9%94%99%E8%AF%AF%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="run方法和start方法"><a href="#run方法和start方法" class="headerlink" title="run方法和start方法"></a>run方法和start方法</h1><p>对于创建过线程的同学都知道，在<code>Thread</code>类中有两个方法需要区分</p>
<ul>
<li><p><code>run</code>方法</p>
</li>
<li><p><code>start</code>方法</p>
</li>
</ul>
<p>先来看一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> createthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartAndRunMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = ()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 直接调用run方法</span></span><br><span class="line">        runnable.run();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的结果如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line">Thread-<span class="number">0</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>从上面的结果中可以看到</p>
<ul>
<li>如果是直接调用<code>run</code>方法那么其实不是启动一个新的线程，而是一个普通的方法调用，因为打印的线程的名字是<code>main</code></li>
<li>使用<code>start</code>方法才是启动一个新的线程</li>
</ul>
<h2 id="start方法"><a href="#start方法" class="headerlink" title="start方法"></a>start方法</h2><p>现在来看一下<code>start</code>方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一件事是判断线程状态</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"><span class="comment">// 第二件事情是将线程加入线程组  </span></span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第三件事情就是调用start0方法  </span></span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到<code>start</code>方法主要做了三件事</p>
<ul>
<li>在启动一个线程之前会先判断一个线程状态<a href="https://www.personalstudy.ltd/2020/04/25/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/">线程的六种状态</a>,这也是为什么执行两次<code>start</code>方法在第二次执行的时候会抛出<code>IllegalThreadStateException</code></li>
</ul>
<p>异常的原因，从这段代码就可以看出来。是因为当执行一次<code>start</code>方法后，线程的状态已经不是0了，所以再一次执行就会抛出这个错误。</p>
<p><font color="green">综合可知，线程的正确启动方式是使用start方法，并且只能使用一次</font></p>
<h1 id="如何正确停止线程"><a href="#如何正确停止线程" class="headerlink" title="如何正确停止线程"></a>如何正确停止线程</h1><p>先给一个总结性原理</p>
<p><strong>停止线程应该使用<code>interrupt</code>来通知，而不是强制停止</strong></p>
<blockquote>
<p>其实这种一种规范，因为很多时候我们并不清楚别人的线程在做什么事情，如果我们强行终止掉另外一个线程，可能会出现一个问题，所以我们要做的应该是给那个需要停止的线程发出一个信号，告诉它应该停止了，给它留下一些时间来处理一些收尾的工作，具体的停止操作应该是由它自己来控制。</p>
</blockquote>
<h2 id="普通情形下停止线程"><a href="#普通情形下停止线程" class="headerlink" title="普通情形下停止线程"></a>普通情形下停止线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stopthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightStopTrheadWithoutSleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// Thread.currentThread().isInterrupted()方法返回的是该线程是否被中断的标识</span></span><br><span class="line">        <span class="keyword">while</span>((i &lt; Integer.MAX_VALUE / <span class="number">2</span>) &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i + <span class="string">"是10000的倍数"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightStopTrheadWithoutSleep());</span><br><span class="line">        thread.start();</span><br><span class="line">      <span class="comment">// 这里休眠一秒是为了让thread线程执行一秒钟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 中断thread线程</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面的代码所示，在主线中使用<code>interrupt</code>方法来中断<code>thread</code>线程，如果在<code>thread</code>线程中没有使用<code>Thread.currentThread().isInterrupted()</code>,那么程序是没有任何影响的，之前已经说过，<code>interrupt</code>的作用只是一个提醒，具体的中断还是要在线程内部自己去判断。</p>
<h2 id="阻塞情形下停止线程"><a href="#阻塞情形下停止线程" class="headerlink" title="阻塞情形下停止线程"></a>阻塞情形下停止线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stopthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightStopTrheadWithSleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((i &lt; <span class="number">1000</span>) &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightStopTrheadWithSleep());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面代码所示，在<code>thread</code>线程中执行完了循环之后就让线程开始<code>sleep</code>1秒钟，在<code>thread</code>线程在休息的时候，主线程中使用<code>interrupt</code>方法中断了<code>thread</code>线程，这样就会出现下图所示的异常</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%92%8C%E9%94%99%E8%AF%AF%E6%96%B9%E5%BC%8F/image-20200502213615779.png" alt="image-20200502213615779"></p>
<h2 id="线程每次迭代后都阻塞"><a href="#线程每次迭代后都阻塞" class="headerlink" title="线程每次迭代后都阻塞"></a>线程每次迭代后都阻塞</h2><p>上面的代码休眠方法是在<code>while</code>循环我外面执行的，如果将休眠的代码放入到<code>while</code>循环内部执行，那么就是会出现线程每次迭代都阻塞的情形。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stopthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightStopTrheadWithSleepEveryLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 每次循环都中断和单次中断的区别就在于使用需要使用线程状态那个条件</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                System.out.println(i++);</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightStopTrheadWithSleepEveryLoop());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码和单次阻塞下的代码基本是相同的，只有两个地方不同</p>
<ul>
<li>将<code>sleep</code>方法放入到<code>while</code>循环当中</li>
<li>在<code>while</code>循环当中不需要使用<code>Thead.currentThread.isInterrupt()</code>方法，因为每一次循环都中断的话，其实判断条件就是那个异常，只要出现了异常，自然就表示线程被中断了。</li>
</ul>
<h1 id="线程不能被中断的情形"><a href="#线程不能被中断的情形" class="headerlink" title="线程不能被中断的情形"></a>线程不能被中断的情形</h1><h2 id="try-catch在while里面"><a href="#try-catch在while里面" class="headerlink" title="try-catch在while里面"></a><code>try-catch</code>在<code>while</code>里面</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stopthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchInWhile</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">200</span> &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(i++);</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TryCatchInWhile());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%92%8C%E9%94%99%E8%AF%AF%E6%96%B9%E5%BC%8F/image-20200502220017024.png" alt="image-20200502220017024"></p>
<p>可以看到虽然出现了异常，但是代码还是会继续执行，为什么我们加上了<code>Thread.currentThread().isInterrupted()</code>这个方法来判断线程是否被中断的条件还是不行呢?这是因为使用了<code>sleep</code>方法导致的</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%92%8C%E9%94%99%E8%AF%AF%E6%96%B9%E5%BC%8F/image-20200502220906477.png" alt="image-20200502220906477"></p>
<h2 id="使用volatile定义的属性作为标识位"><a href="#使用volatile定义的属性作为标识位" class="headerlink" title="使用volatile定义的属性作为标识位"></a>使用volatile定义的属性作为标识位</h2><p>很多时候还会使用<code>volatile</code>定义的属性来作为标识位，通过这个标识位来停止一个线程，使用这种方式在某些情形下是可以停止线程，但是在某些情形下不能停止线程。</p>
<h3 id="能被停止的情形"><a href="#能被停止的情形" class="headerlink" title="能被停止的情形"></a>能被停止的情形</h3><p>对于在线程内部不会在清除中断标识位的操作就可以使用<code>volatile</code>的形式来作为退出线程的判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stopthread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayUseVolatile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadOne());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            ThreadOne.flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadOne</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span> &amp;&amp; !flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程一直执行执行，除非被中断"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例代码可以正确退出线程。在主线程中修改了使用<code>volatile</code>修饰的 标识符，使用<code>volatile</code>关键字修饰的变量具有可见性，所以可以让<code>thread</code>线程看到该变量的变化，这样就可以退出线程。</p>
<h3 id="不能被停止的情形"><a href="#不能被停止的情形" class="headerlink" title="不能被停止的情形"></a>不能被停止的情形</h3><p>上面已经演示过了可以正确使用<code>volatile</code>停止线程的情形，但是在某些情形下是不能正确停止线程的，比如下面消费者和生产者的案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stopthread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayUseVolatile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 这是一个阻塞队列</span></span><br><span class="line">        ArrayBlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums()) &#123;</span><br><span class="line">            consumer.queue.take();</span><br><span class="line">            System.out.println(<span class="string">"一次消费"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"消费者不需要东西了"</span>);</span><br><span class="line">        producer.canceled=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(producer.canceled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">    BlockingQueue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(num&lt;=<span class="number">100000</span> &amp;&amp; !canceled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num%<span class="number">100</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//当超过queue的容量的时候执行put就会阻塞</span></span><br><span class="line">                    queue.put(num);</span><br><span class="line">                    System.out.println(<span class="string">"放入仓库"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者线程结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    BlockingQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Math.random()&gt;<span class="number">0.95</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%92%8C%E9%94%99%E8%AF%AF%E6%96%B9%E5%BC%8F/image-20200504095118197.png" alt="image-20200504095118197"></p>
<p>上面的代码就是使用了一个阻塞队列。</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%92%8C%E9%94%99%E8%AF%AF%E6%96%B9%E5%BC%8F/image-20200504095253702.png" alt="image-20200504095253702"></p>
<p>上面的示例代码，消费者代码执行完成之后改变了消费者中使用<code>volatile</code>定义的变量，但是由于生产者还在处于阻塞状态，所以并没有执行到<code>while</code>循环的判断条件处，这样生产者线程依然是在阻塞中。</p>
<h3 id="修复-使用interrupt"><a href="#修复-使用interrupt" class="headerlink" title="修复(使用interrupt)"></a>修复(使用interrupt)</h3><p>上面演示了不能被正确停止的形式，那么正确的停止方式是什么呢？其实就是使用<code>interrupt</code>方法，上面在<code>main</code>线程值是修改<code>volatile</code>修饰的变量值，现在换成调用需要被中断线程的<code>interrupt</code>方法，并且在需要被中断的线程中响应这个中断事件，然后在<code>while</code>条件中加上<code>Thread.currentThread.isInterrupt()</code>方法来判断当前线程是否被中断即可。</p>
<p>你可能有一个疑问，上面使用<code>volatile</code>在生产者中之所以没有起作用，是因为线程被阻塞了，那么使用<code>interrupt</code>的时候，线程不也是会被阻塞么？当线程阻塞的时候为什么还会走到<code>while</code>判断呢？这是因为在消费者线程即使是在阻塞的状态也是可以接收线程中断的信号的，并且会抛出异常，这样去就可以进行下一次循环，而且这个阻塞队列也不会消除中断标识，所以在<code>while</code>判断中可以使用线程中断标识。</p>
<h1 id="对于线程中方法正确调用姿势"><a href="#对于线程中方法正确调用姿势" class="headerlink" title="对于线程中方法正确调用姿势"></a>对于线程中方法正确调用姿势</h1><h2 id="抛出是首选"><a href="#抛出是首选" class="headerlink" title="抛出是首选"></a>抛出是首选</h2><p>如果在一个线程中(也就是<code>run</code>方法)需要去调用另外一个方法A,那么在方法A中应该如何处理<code>InterruptException</code>呢。我们知道异常的处理方式有两种，一种是<code>try-catch</code>,还有一种是<code>throws</code>,正确的姿势是使用<code>throw</code>来抛出异常，让方法调用方来处理异常。</p>
<h2 id="恢复中断"><a href="#恢复中断" class="headerlink" title="恢复中断"></a>恢复中断</h2><p>当然有可能是不想抛出或者是没有办法抛出，那么此时就需要捕获异常，并且在<code>catch</code>块中再一次恢复中断，怎么恢复中断呢，其实就是调用<code>Thread.currentThread.inerrupt()</code>方法即可。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程常见面试题</title>
    <url>/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="创建线程的方式有几种？"><a href="#创建线程的方式有几种？" class="headerlink" title="创建线程的方式有几种？"></a>创建线程的方式有几种？</h1><p>如果是从本质上来看是两种</p>
<ul>
<li>继承<code>Thread</code>类</li>
<li>实现<code>Runnable</code>接口</li>
</ul>
<p>但是只是从创建方式来看，可能会有多种，比如除了上面所说的，还有</p>
<ul>
<li>通过线程池的方式来创建</li>
<li>通过<code>Callback</code>的方式来创建</li>
</ul>
<a id="more"></a>

<h1 id="通过Runnable方式和继承Thread方式那种方式更好"><a href="#通过Runnable方式和继承Thread方式那种方式更好" class="headerlink" title="通过Runnable方式和继承Thread方式那种方式更好"></a>通过<code>Runnable</code>方式和继承<code>Thread</code>方式那种方式更好</h1><p>使用实现<code>Runnable</code>接口方式更好</p>
<ul>
<li><code>java</code>中是单继承，但是是多实现的，如果继承了<code>Thread</code>类那么就不能继承其余的类</li>
<li>从代码架构层面来说，使用<code>Runnable</code>形式可以解耦</li>
</ul>
<h1 id="一个线程能两次执行start方法么，why"><a href="#一个线程能两次执行start方法么，why" class="headerlink" title="一个线程能两次执行start方法么，why"></a>一个线程能两次执行<code>start</code>方法么，<code>why</code></h1><p>一个线程不能执行两次<code>start</code>方法，可以先看一下<code>start</code>方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 第一个关注点，调用start方法之前会先判断标识</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">          <span class="comment">// 第二个关注点，调用之后会修改标识</span></span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出，在<code>start</code>方法中有两个地方需要注意</p>
<ul>
<li>调用<code>start</code>方法之前会先判断标识</li>
<li>调用之后会修改标识</li>
</ul>
<p>所以调用一次之后，标识已经被修改了，那么再一次调用就会抛出<code>IllegalThreadStateException</code>异常，其实这是和线程的六个状态有关。</p>
<h1 id="会写生产者和消费者模式"><a href="#会写生产者和消费者模式" class="headerlink" title="会写生产者和消费者模式"></a>会写生产者和消费者模式</h1><p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200504225754398.png" alt="image-20200504225754398"></p>
<p>原理图如上图所示，主要就是有三个类</p>
<ul>
<li>仓库<ul>
<li>提供<code>put</code>方法，也就是往仓库中添加东西的方法，该方法需要同步</li>
<li>提供<code>take</code>方法，也就是从仓库往外拿的方法，该方法需要同步</li>
</ul>
</li>
<li>生产者类<ul>
<li>调用仓库的<code>put</code>方法即可</li>
</ul>
</li>
<li>消费者类<ul>
<li>调用仓库的<code>take</code>方法即可</li>
</ul>
</li>
</ul>
<p>其中一种代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> consumerandproducer;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConsumerAndProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyList myList = <span class="keyword">new</span> MyList();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(myList)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(myList)).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyList myList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(MyList myList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myList = myList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            myList.put();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyList myList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(MyList myList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myList = myList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            myList.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Date&gt; list = <span class="keyword">new</span> LinkedList&lt;Date&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者往里面添加数据(锁住的是当前对象)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 已经满了，就不能继续添加</span></span><br><span class="line">        <span class="keyword">while</span> (list.size() == MAX_SIZE) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则就可以继续添加</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"已经有了"</span> + list.size() + <span class="string">"个产品"</span>);</span><br><span class="line">        <span class="comment">// 通知消费者线程</span></span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者往外面拿数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有数据了就要阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还有数据就可以消费</span></span><br><span class="line">        list.poll();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"消费了一个产品，还剩下"</span> + list.size() );</span><br><span class="line">        <span class="comment">// 通知生产者线程</span></span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="使用两个线程从0到100交替打印"><a href="#使用两个线程从0到100交替打印" class="headerlink" title="使用两个线程从0到100交替打印"></a>使用两个线程从0到100交替打印</h1><h2 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DemoOne one = <span class="keyword">new</span> DemoOne();</span><br><span class="line">        <span class="keyword">new</span> Thread(one.<span class="keyword">new</span> OddNumber()).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(one.<span class="keyword">new</span> EvenNumber()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 奇数线程</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OddNumber</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(count++);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偶数线程</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EvenNumber</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println(count++);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种方式可以达到目的，但是效率不够高，为什么呢？因为每一次一个线程执行一次循环后，并不是立即切换到另外一个线程，可能还会继续循环多次，只是因为条件不满足，所以没有打印数据而已，更有效的方式是执行一次之后就立即切换到另外一个线程来执行。这就需要用到线程间通信的方式了，也即是<code>wait</code>和<code>notify</code>版。</p>
<h2 id="wait和notify版"><a href="#wait和notify版" class="headerlink" title="wait和notify版"></a><code>wait</code>和<code>notify</code>版</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TunringRun run = <span class="keyword">new</span> TunringRun();</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TunringRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 只要获取到锁就执行</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(count++);</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的执行顺序如图所示</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/image-20200504233615564.png" alt="image-20200504233615564"></p>
<h1 id="为什么wait需要在同步代码块中使用而sleep不用"><a href="#为什么wait需要在同步代码块中使用而sleep不用" class="headerlink" title="为什么wait需要在同步代码块中使用而sleep不用"></a>为什么<code>wait</code>需要在同步代码块中使用而<code>sleep</code>不用</h1><p>因为<code>wait</code>和<code>notify</code>是有使用顺序的要求的，<code>wait</code>必须是在的<code>notify</code>之前执行，所以如果没有将<code>wait</code>放入的同步代码块中执行，那么就有可能<code>notify</code>先执行，再执行<code>wait</code>的时候就会陷入一直等待的情形。</p>
<p><code>sleep</code>主要是对自己这个线程有影响，没有涉及的线程间通信，所以不需要。</p>
<h1 id="wait-notify和sleep有什么异同"><a href="#wait-notify和sleep有什么异同" class="headerlink" title="wait/notify和sleep有什么异同"></a>wait/notify和sleep有什么异同</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul>
<li><code>wait</code>和<code>sleep</code>都会阻塞</li>
<li>他们都可以响应中断</li>
</ul>
<h2 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h2><ul>
<li>所在类不同</li>
<li><code>wait</code>可以不用传参数，但是<code>sleep</code>一定需要参数</li>
<li><code>wait</code>必须使用在同步代码块中，但是<code>sleep</code>不需要</li>
<li><code>wait</code>会释放锁，但是<code>sleep</code>不会释放锁</li>
</ul>
<h1 id="join期间，线程处于什么状态"><a href="#join期间，线程处于什么状态" class="headerlink" title="join期间，线程处于什么状态"></a>join期间，线程处于什么状态</h1>]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>实现多线程的两种方式</title>
    <url>/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="线程到底有几种创建方式"><a href="#线程到底有几种创建方式" class="headerlink" title="线程到底有几种创建方式"></a>线程到底有几种创建方式</h1><p>如果在网上搜一下线程创建的方式，结果可能如下：</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/image-20200501204634470.png" alt="image-20200501204634470"></p>
<a id="more"></a>

<p>有的说是三种，有的说是四种，还有的两种或者六种，那么到底是几种呢，我们看一下<code>oracle</code>的<code>javase</code>文档就知道了。</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">官方文档</a></p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/image-20200501204851978.png" alt="image-20200501204851978"></p>
<p>现在通过官方文档知道到底是有几种了吧？答案就是<strong>两种</strong>，那么到底是哪两种呢？</p>
<ul>
<li>通过继承<code>Thread</code>来来创建线程</li>
<li>通过实现<code>Runnable</code>接口来创建线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> createthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoWayToCreateThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        One one = <span class="keyword">new</span> One();</span><br><span class="line">        one.start();</span><br><span class="line">        Two two = <span class="keyword">new</span> Two();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Two()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过继承Threa来创建线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过实现Runnable接口的方式来实现一个线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建线程的本质"><a href="#创建线程的本质" class="headerlink" title="创建线程的本质"></a>创建线程的本质</h2><p>上面写了线程创建的两种方式，线程创建中其实都是执行<code>run</code>方法，只不过使用继承<code>Thread</code>类的时候是执行<code>Thread</code>类中<code>run</code>方法，如果是实现<code>Runnable</code>接口，则是执行<code>Runnable</code>接口中的<code>run</code>方法。</p>
<p><font color="red">注:无论是使用Thread还是Runnable，启动线程都是使用需要Thread，所以其实都是调用Thread类的run方法</font></p>
<p>看一下<code>Thread</code>的<code>run</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">    target.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以如果是使用<code>Runnable</code>的形式实际上是将我们实现<code>Runnable</code>的类传到<code>Thread</code>类中，然后调用<code>run</code>方法的时候就是调用我们的<code>run</code>方法。如果是继承<code>Thread</code>类的话我们自己的类也会重写<code>run</code>方法，子类重写父类的方法，只会调用子类的方法，所以<code>Thread</code>类中<code>run</code>方法就不会执行。</p>
<h2 id="两种方式同时使用"><a href="#两种方式同时使用" class="headerlink" title="两种方式同时使用"></a>两种方式同时使用</h2><p>上面说有两种方式可以创建线程，那么如果我们将两种方式一起使用，会是怎么个情形呢？请看下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> createthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseTwoWayTogather</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"使用实现Runnable的方式来创建线程"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"使用继承Thread的方式来创建线程"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面通过匿名内部类的方式将两种创建线程的方式同时使用，那么打印的结果会是什么呢？</p>
<p>结果是： <strong>使用继承Thread的方式来创建线程</strong>？<strong>why</strong></p>
<p>上面已经说了创建线程的本质是执行<code>Thread</code>类中<code>run</code>，如果两种方式同时使用，那么子类中重写了父类方法，父类方法就不会继续执行，所以此时执行的是子类的<code>run</code>方法，这样<code>Thread</code>类中的<code>run</code>方法就不会执行，所以也就不会是通过实现<code>Runnable</code>的方式来创建线程。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>查看线程状态</title>
    <url>/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>这里主要是介绍<code>jdk</code>自带的工具来查看线程状态</p>
<h1 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h1><ol>
<li><code>new</code><ol>
<li>比如使用<code>new Thread()</code>方式创建一个线程</li>
</ol>
</li>
<li><code>runnable</code><ol>
<li>对于<code>runnable</code>有两种理解<ol>
<li>一种是正在运行的，也就是拿到了<code>cpu</code>执行权</li>
<li>一种是可运行的，也就是在调用线程的<code>start()</code>方法后，就表示可运行，但是想要真正的运行还需要拿到<code>cpu</code>的执行权</li>
</ol>
</li>
</ol>
</li>
<li><code>blocked</code><ol>
<li>从<code>runnable</code>状态去获取锁失败的时候就会是<code>blocked</code>状态</li>
</ol>
</li>
<li><code>waiting</code></li>
<li><code>timed waiting</code></li>
<li><code>TERMINATED</code></li>
</ol>
<a id="more"></a>

<h2 id="线程不同状态间切换"><a href="#线程不同状态间切换" class="headerlink" title="线程不同状态间切换"></a>线程不同状态间切换</h2><p>不同状态间切换需要记住两点</p>
<ol>
<li><code>new</code>状态和<code>runnable</code>状态是一定会经历的，并且是最先经历的两个阶段</li>
<li>其余的四个状态都是和<code>runnable</code>状态来进行交互的</li>
</ol>
<p><strong>在网上找了一个线程状态切换图</strong></p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/image-20200429233508762.png" alt="image-20200429233508762"></p>
<h2 id="图解说明"><a href="#图解说明" class="headerlink" title="图解说明"></a>图解说明</h2><p><font color="red">上面的图其实还不是很正确,因为从<strong>等待状态可以直接进入阻塞状态</strong>，因为上面图中显示从waiting到Runnable的方式有notify或notifyAll等方法，但是如果是多个线程在等待同一个锁，那么当没有获取到锁的线程就会陷入到阻塞状态(也可以认为依然是等待状态)，当然上面的图对于一个线程来说是正确的。还有一点就是到终止状态的不仅仅是执行完成，如果是出现了异常也可以直接从其余的状态进入到终止状态。</font></p>
<h1 id="使用jconsole查看线程状态"><a href="#使用jconsole查看线程状态" class="headerlink" title="使用jconsole查看线程状态"></a>使用jconsole查看线程状态</h1><p><code>jconsole</code>在<code>jdk</code>的<code>bin</code>目录下，我们直接打开</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/image-20200425220414500.png" alt="image-20200425220414500"></p>
<p>找到我们自己的线程进行连接</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/image-20200425220541675.png" alt="image-20200425220541675"></p>
<p>如上图所示，可以看到线程，当点击某一个线程的时候可以看到线程的状态，还可以检测死锁。</p>
<h1 id="使用jstack查看线程状态"><a href="#使用jstack查看线程状态" class="headerlink" title="使用jstack查看线程状态"></a>使用jstack查看线程状态</h1><h2 id="使用jps查找pid"><a href="#使用jps查找pid" class="headerlink" title="使用jps查找pid"></a>使用jps查找pid</h2><p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/image-20200425220654461.png" alt="image-20200425220654461"></p>
<h2 id="打开jstack"><a href="#打开jstack" class="headerlink" title="打开jstack"></a>打开jstack</h2><p><code>jstack</code>也是在<code>jdk</code>的<code>bin</code>目录下，不过我们可以直接打开<code>cmd</code>来执行(前提条件是配置了<code>java</code>环境变量)</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/image-20200425220854097.png" alt="image-20200425220854097"></p>
<p>如图所示可以通过<code>jstack</code>命令可以看到线程的状态。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程如何处理未捕获异常</title>
    <url>/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="子线程异常不影响父线程"><a href="#子线程异常不影响父线程" class="headerlink" title="子线程异常不影响父线程"></a>子线程异常不影响父线程</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> uncaughtexception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UncaughtExceptionDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> UncaughtExceptionDemo()).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面代码所示，有两个线程，在子线程中抛出了异常，但是不会影响到父线程的业务，正常来讲，当出现异常时我们需要处理，不能直接略过去。</p>
<a id="more"></a>

<h1 id="父线程不能捕获子线程异常"><a href="#父线程不能捕获子线程异常" class="headerlink" title="父线程不能捕获子线程异常"></a>父线程不能捕获子线程异常</h1><p>上面的案例说子线程出现了异常，父线程没有受到印象，那我们在父线程中去捕获异常不就行了么？看下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> uncaughtexception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaughtChildThreadExceptionInParent</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> UncaughtExceptionDemo(), <span class="string">"thread-1"</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> UncaughtExceptionDemo(), <span class="string">"thread-2"</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> UncaughtExceptionDemo(), <span class="string">"thread-3"</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> UncaughtExceptionDemo(), <span class="string">"thread-4"</span>).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"捕获到了运行时异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中在父线程中使用了<code>try-catch</code>来捕获<code>RuntimeException</code>异常(因为子线程中抛出的就是<code>RuntimeException</code>异常)但是当你运行的时候就会发现异常并没有捕获到，因为</p>
<ul>
<li><code>RuntimeException</code>异常时发生到子线程当中</li>
<li><code>try-catch</code>只能捕获当前线程发生的异常，所以父线程是不会捕获到子线程异常的</li>
</ul>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="子线程中捕获-不推荐"><a href="#子线程中捕获-不推荐" class="headerlink" title="子线程中捕获(不推荐)"></a>子线程中捕获(不推荐)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> uncaughtexception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaughtChildThreadExceptionInParent</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CaughtChildThreadExceptionInParent(), <span class="string">"thread-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CaughtChildThreadExceptionInParent(), <span class="string">"thread-2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CaughtChildThreadExceptionInParent(), <span class="string">"thread-3"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> CaughtChildThreadExceptionInParent(), <span class="string">"thread-4"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"捕获到了运行时异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接结果</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/image-20200505090623577.png" alt="image-20200505090623577"></p>
<p>使用这种方式确实可以捕获到异常，但是每一个线程中都要写捕获异常的代码，显然这种方式是不优雅的。下线提供一种更优雅的方式</p>
<h2 id="全局异常"><a href="#全局异常" class="headerlink" title="全局异常"></a>全局异常</h2><p><code>Thread</code>类中提供了一个<code>UncaughtExceptionHandler</code>接口，这个接口专门用来处理线程的异常的。</p>
<p>使用步骤：</p>
<ul>
<li>自己定义一个类实现<code>UncaughtExceptionHandler</code></li>
<li>在需要使用的线程类中设置异常处理器</li>
</ul>
<h3 id="自定义类实现UncaughtExceptionHandler"><a href="#自定义类实现UncaughtExceptionHandler" class="headerlink" title="自定义类实现UncaughtExceptionHandler"></a>自定义类实现<code>UncaughtExceptionHandler</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> uncaughtexception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getAnonymousLogger();</span><br><span class="line">        logger.log(Level.WARNING, <span class="string">"线程异常，终止啦"</span> + t.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用自定义异常处理类"><a href="#使用自定义异常处理类" class="headerlink" title="使用自定义异常处理类"></a>使用自定义异常处理类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> uncaughtexception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseMyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 使用我们自己定义的异常处理器</span></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseMyUncaughtExceptionHandler(), <span class="string">"thread-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseMyUncaughtExceptionHandler(), <span class="string">"thread-2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseMyUncaughtExceptionHandler(), <span class="string">"thread-3"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseMyUncaughtExceptionHandler(), <span class="string">"thread-4"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码和上面的代码的不同只有一个地方，就是<code>Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</code></p>
<p>执行结果</p>
<p><img src="/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/image-20200505091337198.png" alt="image-20200505091337198"></p>
<p>可以看到，虽然我们自己在线程中没有捕获异常，但是设置了全局异常处理器后，在异常处理器类中可以捕获到未捕获的异常，我们要处理的逻辑可以在异常处理器类中进行处理。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程间通信的几种方式</title>
    <url>/2020/06/06/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="什么是线程间通信"><a href="#什么是线程间通信" class="headerlink" title="什么是线程间通信"></a>什么是线程间通信</h1><a id="more"></a>

<h1 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h1><ul>
<li><code>suspend</code>和<code>resume</code></li>
<li><code>wait</code>和<code>notify</code></li>
<li><code>park</code>和<code>unpark</code></li>
</ul>
<p><a href="https://gitee.com/Gwei11/code/tree/master/javabase/%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">示例代码</a></p>
<h2 id="suspend和resume"><a href="#suspend和resume" class="headerlink" title="suspend和resume"></a><code>suspend</code>和<code>resume</code></h2><ul>
<li>这两个方法已经被弃用，主要有以下两个原因<ul>
<li><code>resume</code>必须在<code>suspend</code>之后调用</li>
<li>如果加了锁的话，<code>suspend</code>方法是不会释放锁的</li>
</ul>
</li>
<li>案例代码请点击上面的<strong>示例代码</strong>链接</li>
</ul>
<h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a><code>wait</code>和<code>notify</code></h2><p>当一个线程调用一个<strong>共享变量</strong>的<code>wait</code>方法时，该调用线程会被挂起。在以下情形下才返回</p>
<ol>
<li>其他线程调用了该<strong>共享变量</strong>的<code>notify()</code>或<code>notifyAll()</code>方法</li>
<li>其他线程调用了<strong>该线程</strong>的<code>interrupt()</code>方法，该线程会抛出<code>InterruptedException</code>异常返回</li>
</ol>
<p><font color="red">注：上面所说的共享变量其实就是指锁，也就是说需要获取对象的监视器锁才能执行wait方法</font></p>
<p>那么如何获取对象监视器锁呢？有以下两种方式：</p>
<ol>
<li>使用<code>synchronized</code>同步代码块</li>
<li>使用<code>synchronized</code>同步方法</li>
</ol>
<ul>
<li><code>wait</code>和<code>notify</code>必须加锁才能使用</li>
<li><code>wait</code>调用时会释放锁</li>
<li><code>wait</code>方法和<code>notify</code>方法也有调用顺序问题，如果先调用<code>notify</code>，然后再调用<code>wait</code>会发生死锁</li>
</ul>
<h2 id="park和unpark"><a href="#park和unpark" class="headerlink" title="park和unpark"></a><code>park</code>和<code>unpark</code></h2><ul>
<li><code>park</code>和<code>unpark</code>是<code>LockSupport</code>类中静态方法</li>
<li>这两个方法解决了顺序问题，也就是无论哪个先执行都可以，这是一种令牌机制</li>
<li>但是这两个方法没有解决锁的问题，也就是<code>park</code>方法中如果拿到了锁，当执行<code>park</code>的时候不会释放锁</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>exception和error</title>
    <url>/2020/06/06/java/%E5%BC%82%E5%B8%B8/exception%E5%92%8Cerror/</url>
    <content><![CDATA[<h1 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h1><p><code>Throwable</code>是<code>Exception</code>和<code>error</code>的父类。而<code>Exception</code>和<code>error</code>的作用不同，这里的两个不同的子类体现的是异常中分类的思想。</p>
<p><img src="/2020/06/06/java/%E5%BC%82%E5%B8%B8/exception%E5%92%8Cerror/image-20200303201919251.png" alt="image-20200303201919251"></p>
<p>如上图所示，<code>Exception</code>和<code>Error</code>的分类依据是对于会出现问题带代码我们是否应该捕获。</p>
<a id="more"></a>

<h1 id="应该捕获-Exception"><a href="#应该捕获-Exception" class="headerlink" title="应该捕获(Exception)"></a>应该捕获(Exception)</h1><p>对于<code>Exception</code>我们是应该捕获的，不过<code>Exception</code>中也可以进行分类，分类的一句是是否能检查，也就是该异常是在编译器就知道还是在运行时才能知道。</p>
<h2 id="checked"><a href="#checked" class="headerlink" title="checked"></a>checked</h2><p>对于在编译期就可以知道的异常就是可检查的异常，比如<code>ClassNotFoundException</code></p>
<h2 id="unchecked"><a href="#unchecked" class="headerlink" title="unchecked"></a>unchecked</h2><p>对于在编译期不知道，在运行时可能会出现的异常就是运行时异常，比如</p>
<ul>
<li><code>NullPointerException</code></li>
<li><code>ArrayIndexOutOfBoundException</code></li>
<li><code>ClassCastException</code></li>
</ul>
<h1 id="不能捕获-Error"><a href="#不能捕获-Error" class="headerlink" title="不能捕获(Error)"></a>不能捕获(Error)</h1><p>对于有些错误出现了我们是不能处理的，很多都是<code>jvm</code>虚拟机自身出了问题，对于这样的问题即使我们能捕获也是处理不了的，所以这些不可捕获的类别就通过<code>Error</code>来定义。比如说下面的几个错误</p>
<ul>
<li><code>OutOfMemoryError</code></li>
<li><code>StackOverFlowError</code></li>
<li><code>NoClassDefFoundError</code></li>
</ul>
<h1 id="throw和throws"><a href="#throw和throws" class="headerlink" title="throw和throws"></a>throw和throws</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThrow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        one();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"by / zero"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Throw"><a href="#Throw" class="headerlink" title="Throw"></a>Throw</h2><ul>
<li>作用在方法内，表示抛出具体异常，由方法体内的语句处理。</li>
<li>具体向外抛出的动作，所以它抛出的是一个异常实体类。若执行了<code>Throw</code>一定是抛出了某种异常。</li>
</ul>
<h2 id="Throws"><a href="#Throws" class="headerlink" title="Throws"></a>Throws</h2><ul>
<li>作用在方法的声明上，表示如果抛出异常，则由该方法的调用者来进行异常处理。</li>
<li>主要的声明这个方法会抛出会抛出某种类型的异常，让它的使用者知道捕获异常的类型。出现异常是一种可能性，但不一定会发生异常。</li>
</ul>
<h1 id="ClassNotFoundException和NoClassDefFoundError"><a href="#ClassNotFoundException和NoClassDefFoundError" class="headerlink" title="ClassNotFoundException和NoClassDefFoundError"></a>ClassNotFoundException和NoClassDefFoundError</h1><ul>
<li>对于<code>ClassNotFoundException</code>是一个检查异常，比如下面的代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.classobject;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testException</span> <span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码去加载<code>mysql</code>数据库驱动，如果没有加载到就会出现<strong>类没有找到的异常</strong></p>
<ul>
<li><code>NoClassDefFoundError</code>是<code>Error</code>，这里说明是可以代码可以通过编译，但是实际运行的是在发现找不到编译后的<code>class</code>就会出现这个错误.</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>final和finally和finalize</title>
    <url>/2020/06/06/java/%E5%BC%82%E5%B8%B8/final%E5%92%8Cfinally%E5%92%8Cfinalize%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>要想区分这几个关键字的不同之处，就需要弄清楚每一个关键字的本来含义，也就是说为什么想要设置这样的一个关键字，只能搞清楚了一个关键字的本来含义才能明白他们的本质区别。</p>
<a id="more"></a>

<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>从作用上来看，<code>final</code>是可以用来修饰类，方法，变量。并且都有不同的含义。</p>
<h2 id="修饰Class"><a href="#修饰Class" class="headerlink" title="修饰Class"></a>修饰Class</h2><p>被<code>final</code>修饰的类是不可以被继承的，也就是该类不可扩展，不可变了。</p>
<h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><p>对于被<code>final</code>修饰的方法是不可以被重写的，也就是该方法不可变了。</p>
<h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><p>对于被<code>final</code>修饰的变量是不可以被改变的。这也是说不可变。</p>
<h3 id="引用与非引用"><a href="#引用与非引用" class="headerlink" title="引用与非引用"></a>引用与非引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.testfinal;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">final</span> String a;</span><br><span class="line">        <span class="comment">//i = 10; 错误</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"10"</span>);</span><br><span class="line">        list.add(<span class="string">"20"</span>);</span><br><span class="line">        <span class="comment">//list = new ArrayList&lt;&gt;(); 错误</span></span><br><span class="line">        a = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="comment">//a = "world"; 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面的代码，无论是什么类型，只要是被<code>final</code>修饰就<code>只能赋值一次</code>。但是对于引用类型和非引用类型还是有一点区别的，可以看到非引用类型就是变量的值不可变。而引用类型如图所示：</p>
<p><img src="/2020/06/06/java/%E5%BC%82%E5%B8%B8/final%E5%92%8Cfinally%E5%92%8Cfinalize%E8%AE%B2%E8%A7%A3/image-20200303084332313.png" alt="image-20200303084332313"></p>
<p>不可变指的是栈中的变量保存的指向堆中的地址是不可变的，但是堆中的对象可以变，就像上面的代码中写的一样，<code>list</code>依然可以添加元素。</p>
<h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><p>从上面的描述中可以都可以看到一个共同的字眼，就是不可变。其实这也是<code>final</code>关键字的本来含义，就是只有是被<code>final</code>修饰的内容是不想被改变的。要知道我们不是一个人在开发，既然很多人要协作，那么有些不想被别人改变的内容就可以通过<code>final</code>关键字来修饰，这样别人就知道这些变量或方法或类是不想被改变的。</p>
<h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><p><code>finally</code>是<code>java</code>为了保证重点代码一定被执行，通常是用来进行释放资源的操作。但是<code>java7</code>之后推荐使用<code>try-with-resource</code>来释放资源。    </p>
<h2 id="finally的本质"><a href="#finally的本质" class="headerlink" title="finally的本质"></a>finally的本质</h2><p>上面说<code>finally</code>的作用是保证重点代码都可以被执行，那么是如何保证的呢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.testpackage;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        one();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在使用反编译命令  <code>javap -p -v -l FinallyDemo4.class</code>来看一下反编译之后的字节码文件。</p>
<p><img src="/2020/06/06/java/%E5%BC%82%E5%B8%B8/final%E5%92%8Cfinally%E5%92%8Cfinalize%E8%AE%B2%E8%A7%A3/image-20200303193845304.png" alt="image-20200303193845304"></p>
<p>通过分析编译后的字节码可知，之所以说<code>finally</code>中的代码一定会被执行到，是因为其实是将<code>finally</code>中的代码既拷贝到了<code>try</code>当中，也拷贝到了<code>catch</code>当中，所以无论代码有没有发生异常，<code>finally</code>中的代码都会执行到。</p>
<h2 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h2><p><strong><code>jdk7</code>之前</strong></p>
<p>平时我们经常会使用的输入流和输出流的，这两个流使用完成之后都是需要进行关闭，一般的操作如下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.testpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseResource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:/axis.log"</span>);</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"E:/axis.log"</span>);</span><br><span class="line">            <span class="comment">// 缓冲区</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面有很多与业务代码无关的代码。</p>
<p><strong><code>jdk7</code>及以后</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseResource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        withResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">withResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"D:/axis.log"</span>);</span><br><span class="line">        OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"E:/axis.log"</span>))&#123;</span><br><span class="line">            <span class="comment">// 缓冲区</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>try-with-resource</code>代码会简单很多，做法也很简单，就是将需要关闭的资源定义在<code>try()</code>的括号中。</p>
<h2 id="finally不执行"><a href="#finally不执行" class="headerlink" title="finally不执行"></a>finally不执行</h2><p>虽然说<code>finally</code>的目的是为了让重要的代码 <strong>一定</strong>可以执行到，但是这里的一定也不是绝对的，比如下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.testpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"try块"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在<code>try</code>块里面执行了 <code>System.exit(1)</code>之后，在<code>finally</code>中的内容就不会执行了，因为执行了<code>System.exit(1)</code>实际上是已经退出了<code>jvm</code>虚拟机。</p>
<h2 id="多个位置的return的问题"><a href="#多个位置的return的问题" class="headerlink" title="多个位置的return的问题"></a>多个位置的return的问题</h2><p>注意：如果在<code>finally</code>中写了<code>return</code>会吞掉异常。</p>
<h3 id="只有try中有return"><a href="#只有try中有return" class="headerlink" title="只有try中有return"></a>只有try中有return</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.testpackage;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(one());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中只有在<code>try</code>中有<code>return</code>，但是在<code>finally</code>中修改了<code>i</code>的值，那么返回的结果是什么呢？看一下反编译后的字节码文件 <code>javap -p -v -l FinallyDemo4.class</code></p>
<p><img src="/2020/06/06/java/%E5%BC%82%E5%B8%B8/final%E5%92%8Cfinally%E5%92%8Cfinalize%E8%AE%B2%E8%A7%A3/image-20200303195339178.png" alt="image-20200303195339178"></p>
<p>通过分析编译后的字节码可以返回的结果是10，也就是说虽然<code>finally</code>中修改了变量的值，但是返回的还是<code>try</code>块中的值。</p>
<h3 id="try和finally中都有return"><a href="#try和finally中都有return" class="headerlink" title="try和finally中都有return"></a>try和finally中都有return</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.testpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(one());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下编译后的字节码文件</p>
<p><img src="/2020/06/06/java/%E5%BC%82%E5%B8%B8/final%E5%92%8Cfinally%E5%92%8Cfinalize%E8%AE%B2%E8%A7%A3/image-20200303195954280.png" alt="image-20200303195954280"></p>
<p>由上面的分析可知，当<code>try</code>和<code>finally</code>中都有<code>return</code>的时候，最终返回的是<code>finally</code>中修改的值。</p>
<h3 id="try和catch和finally中都有"><a href="#try和catch和finally中都有" class="headerlink" title="try和catch和finally中都有"></a>try和catch和finally中都有</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.testpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(one());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上面的代码，三个块中都有<code>return</code>，并且发生了异常，此时来看下编译后的字节码</p>
<p><img src="/2020/06/06/java/%E5%BC%82%E5%B8%B8/final%E5%92%8Cfinally%E5%92%8Cfinalize%E8%AE%B2%E8%A7%A3/image-20200303201301427.png" alt="image-20200303201301427"></p>
<p>通过上面的分析可知，最终返回的是30</p>
<h2 id="finally中使用return吞掉异常"><a href="#finally中使用return吞掉异常" class="headerlink" title="finally中使用return吞掉异常"></a>finally中使用return吞掉异常</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.testpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = one();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span> /<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码会输出的结果是20，而且也不会有异常信息。看一下编译后的字节码中<code>one</code>方法的信息</p>
<p><img src="/2020/06/06/java/%E5%BC%82%E5%B8%B8/final%E5%92%8Cfinally%E5%92%8Cfinalize%E8%AE%B2%E8%A7%A3/image-20200303194149195.png" alt="image-20200303194149195"></p>
<p>现在去掉<code>finally</code>中的<code>return</code>，再反编译看一下</p>
<p><img src="/2020/06/06/java/%E5%BC%82%E5%B8%B8/final%E5%92%8Cfinally%E5%92%8Cfinalize%E8%AE%B2%E8%A7%A3/image-20200303194348354.png" alt="image-20200303194348354"></p>
<p>可以看到最后是用<code>athrow</code>的，<strong>所以我们写代码是最好是不要在<code>finally</code>中写<code>return</code>语句。</strong></p>
<h1 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h1><p>在<code>java</code>垃圾回收中，使用的可达性分析算法来判断一个垃圾是不是可以被回收，但是即使在可达性分析中该对象是不可达的，也不会立即被回收。此时他们暂时处于缓刑阶段，要宣告一个对象死亡，至少需要经历<strong>两次标记过程</strong></p>
<ul>
<li>如果对象在进行可达性分析后发现没有与<code>GC Root</code>相连接的引用链，那么将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，当对象没有覆盖<code>finalize()</code>方法时，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这两种情形视为<strong>“没有必要执行”</strong></li>
<li>如果该对象判断为有必要执行<code>finalize()</code>方法，那么该对象将中被放置在一个叫做<code>F-Queue</code>队列中，并且在稍后由一个虚拟机自动建立的，优先级低的<code>Finalizer</code>线程去执行它。<code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后<code>GC</code>将对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果对象在<code>finalize()</code>中成功拯救自己(只要重新与引用链上的任何一个对象建立关联即可，比如将自己(<code>this</code>关键字)赋值给某个类变量或对象的成员变量，那么在第二次标记的时候会被将它移除“<strong>即将回收</strong>”的集合)，如果对象在此时还没有逃脱，那就说明需要被回收了。</li>
</ul>
<p>所以<code>finalize</code>可以用于对象自救，但是这种方式最好不要使用，效率很低。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举</title>
    <url>/2020/06/06/java/%E6%9E%9A%E4%B8%BE/%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="基本的枚举定义"><a href="#基本的枚举定义" class="headerlink" title="基本的枚举定义"></a>基本的枚举定义</h1><p><code>enum</code> 的全称为 <code>enumeration</code>， 是 <code>JDK 1.5</code>  中引入的新特性，存放在 <code>java.lang</code> 包中。</p>
<p>定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.twolovelypig;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumMain &#123;</span><br><span class="line">	MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>输出枚举值代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.twolovelypig;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (EnumMain e : EnumMain.values()) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="enum对象基本方法"><a href="#enum对象基本方法" class="headerlink" title="enum对象基本方法"></a>enum对象基本方法</h1><ul>
<li><p><code>int compareTo(E o)</code>    该方法用来比较枚举与指定对象的顺序</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//值为6，表明SUN在MON后面六位</span></span><br><span class="line">	System.out.println(EnumMain.SUN.compareTo(EnumMain.MON));</span><br><span class="line">	<span class="comment">//值为-2，表明tue比thu小两位(tue在thu前面两位)</span></span><br><span class="line">	System.out.println(EnumMain.TUE.compareTo(EnumMain.THU));</span><br><span class="line">	<span class="comment">//值为0，表示二者是一样的</span></span><br><span class="line">	System.out.println(EnumMain.MON.compareTo(EnumMain.MON));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  需要注意的是这里比较的值是有大小和正负的，不是说后面的与前面的相比结果就是1，也有可能是其他正数，具体结果是几就需要看后面的枚举是在前面的枚举<strong>后几位</strong></p>
</li>
<li><p><code>Class&lt;E&gt; ``**getDeclaringClass**()</code>返回与枚举常量的枚举类型相对应的<code>class</code>对象</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.twolovelypig;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		EnumMain enumMain = EnumMain.FRI;</span><br><span class="line">		 System.out.println(<span class="string">"getDeclaringClass(): "</span> + enumMain.getDeclaringClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出的结果是类的全路径: <code>getDeclaringClass(): top.twolovelypig.EnumMain</code></p>
</li>
<li><p><code>String name()</code>返回此枚举常量的名称</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	EnumMain enumMain = EnumMain.FRI;</span><br><span class="line">	System.out.println(<span class="string">"name(): "</span> + enumMain.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出结果是: <code>name(): FRI</code></p>
</li>
<li><p><code>int ordinal()</code> 返回枚举常量的序数(初始常量序数为0)</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	EnumMain enumMain = EnumMain.FRI;</span><br><span class="line">	System.out.println(<span class="string">"ordinal(): "</span> + enumMain.ordinal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出结果是4，因为<code>FRI</code>是第五个，初始常量序数是0，所以输出结果是4</p>
</li>
<li><p><code>String toString()</code> 返回枚举常量的名称</p>
</li>
</ul>
<h1 id="给enum自定义属性和方法-带参数的enum"><a href="#给enum自定义属性和方法-带参数的enum" class="headerlink" title="给enum自定义属性和方法(带参数的enum)"></a>给enum自定义属性和方法(带参数的enum)</h1><p><code>enum</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.twolovelypig;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumMain &#123; </span><br><span class="line">	MON(<span class="string">"星期一"</span>, <span class="number">1</span>), </span><br><span class="line">	TUE(<span class="string">"星期二"</span>, <span class="number">2</span>), </span><br><span class="line">	WED(<span class="string">"星期三"</span>, <span class="number">3</span>), </span><br><span class="line">	THU(<span class="string">"星期四"</span>, <span class="number">4</span>), </span><br><span class="line">	FRI(<span class="string">"星期五"</span>, <span class="number">5</span>), </span><br><span class="line">	SAT(<span class="string">"星期六"</span>, <span class="number">6</span>), </span><br><span class="line">	SUN(<span class="string">"星期天"</span>,<span class="number">7</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 成员变量  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumMain</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通方法  根据index获取name</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNameByIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (EnumMain c : EnumMain.values()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (c.getIndex() == index) &#123;  </span><br><span class="line">                <span class="keyword">return</span> c.name;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通方法  根据index获取name</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndexByName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (EnumMain c : EnumMain.values()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (c.name.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">return</span> c.index;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get set 方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> index;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中<code>getIndexByName()</code>方法中需要注意<code>c.name</code>与<code>c.getName()</code>的区别，<code>c.name</code>获取的是中文比如<strong>星期三</strong>，而<code>c.getName()</code>的结果是<strong>FRI</strong>。</p>
<p>测试代码，根据名称获取索引，根据索引获取名称等:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.twolovelypig;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		EnumMain enumMain = EnumMain.FRI;</span><br><span class="line">		<span class="comment">//普通get方法		输出结果是5</span></span><br><span class="line">		System.out.println(enumMain.getIndex());</span><br><span class="line">		<span class="comment">//普通getName()方法		输出结果是星期五</span></span><br><span class="line">		System.out.println(enumMain.getName());</span><br><span class="line">		<span class="comment">//根据index获取name		输出结果是星期三</span></span><br><span class="line">		System.out.println(EnumMain.getNameByIndex(<span class="number">3</span>));</span><br><span class="line">		<span class="comment">//根据name获取index		输出结果是3</span></span><br><span class="line">		System.out.println(EnumMain.getIndexByName(<span class="string">"星期三"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对枚举的理解"><a href="#对枚举的理解" class="headerlink" title="对枚举的理解"></a>对枚举的理解</h1><p>==可能不好理解的就是上面具有参数的枚举，其实只需要记住一点，<strong>java中一切皆对象</strong>，可以把枚举页当做一个类，这样来看的话上面的代码可以写成下面这样==:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.twolovelypig;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMain</span> </span>&#123; 	</span><br><span class="line">    <span class="comment">// 成员变量  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumMain</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// get set 方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> index;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的类比较好理解吧，就是具有两个属性而已，然后呢就是一个私有构造方法以及get/set方法。而对于枚举中的这些声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MON(<span class="string">"星期一"</span>, <span class="number">1</span>), </span><br><span class="line">TUE(<span class="string">"星期二"</span>, <span class="number">2</span>), </span><br><span class="line">WED(<span class="string">"星期三"</span>, <span class="number">3</span>), </span><br><span class="line">THU(<span class="string">"星期四"</span>, <span class="number">4</span>), </span><br><span class="line">FRI(<span class="string">"星期五"</span>, <span class="number">5</span>), </span><br><span class="line">SAT(<span class="string">"星期六"</span>, <span class="number">6</span>), </span><br><span class="line">SUN(<span class="string">"星期天"</span>,<span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<p>其实就是该枚举类的对象，每一个声明都是一个对象，也就是这里其实有七个对象，此时简单理解枚举与类的区别就是枚举中对象是数量固定，相当于在一开始就实例化了几个固定的对象而已。然后后面哪些根据<code>key</code>获取<code>name</code>，以及根据<code>name</code>获取<code>key</code>都是自己加的一些方法而已。</p>
<h1 id="enumMap"><a href="#enumMap" class="headerlink" title="enumMap"></a>enumMap</h1><p><strong>以下内容来自《java编程的逻辑》这本书。</strong></p>
<blockquote>
<p>如果需要一个Map的实现类，并且建的类型为枚举类型，可以使用HashMap,但应该使用一个专门的实现类EnumMap。因为枚举类型有两个特征:</p>
<ul>
<li>枚举所有可能的值时有限的并且是预定义的</li>
<li>所有的枚举值有一个顺序</li>
</ul>
<p>这两个特征可以更为高效的实现Map接口。</p>
</blockquote>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>比如有一批关于衣服的记录，想要通过尺寸统计衣服的数量，定义一个简单的枚举类<code>Size</code>；都表示衣服的尺寸。</p>
<p><code>Size</code>枚举:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size&#123;</span><br><span class="line">    SMALL, MEDIUM, LARGE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Clothes</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clothes</span></span>&#123;</span><br><span class="line">    String id;</span><br><span class="line">    Size size;</span><br><span class="line">    <span class="comment">//get与set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按尺寸统计数量:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Size, Integer&gt; <span class="title">countBySize</span><span class="params">(List&lt;Clothes&gt; clothes)</span></span>&#123;</span><br><span class="line">    Map&lt;Size, Integer&gt; map = <span class="keyword">new</span> EnumMap(Size<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span>(Clothes c : clothes)&#123;</span><br><span class="line">        Size size = c.getSize();</span><br><span class="line">        Integer count = map.get(size);</span><br><span class="line">        <span class="keyword">if</span>(count != <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(size, count+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(size, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==需要注意EnumMap的构造方法==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Size, Integer&gt; map = <span class="keyword">new</span> EnumMap(Size<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>EnumMap</code>需要传递一个<strong>类型</strong>信息，<code>Size.class</code>表示枚举类<code>Size</code>的运行时信息，需要这个参数是因为<code>EnumMap</code>要知道具体的枚举类是什么。</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Clothes&gt; clothes = Arrays.asList(</span><br><span class="line">	<span class="keyword">new</span> Clothes[]&#123;</span><br><span class="line">        <span class="keyword">new</span> Clothes(<span class="string">"c001"</span>, Size.SMALL),</span><br><span class="line">        <span class="keyword">new</span> Clothes(<span class="string">"c002"</span>, Size.MEDIUM),</span><br><span class="line">        <span class="keyword">new</span> Clothes(<span class="string">"c003"</span>, Size.LARGE),</span><br><span class="line">        <span class="keyword">new</span> Clothes(<span class="string">"c004"</span>, Size.SMALL),</span><br><span class="line">        <span class="keyword">new</span> Clothes(<span class="string">"c005"</span>, Size.MEDIUM),</span><br><span class="line">        <span class="keyword">new</span> Clothes(<span class="string">"c006"</span>, Size.LARGE)</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">System.out.println(countBySize(clothes));</span><br></pre></td></tr></table></figure>

<p>需要说明的是，<code>EnumMap</code>是保证顺序的，输出是按照键在枚举中的顺序的。</p>
<h2 id="enum的另外两个构造方法"><a href="#enum的另外两个构造方法" class="headerlink" title="enum的另外两个构造方法"></a>enum的另外两个构造方法</h2><p>除了以上介绍的构造方法，EnumMap还有两个构造方法，可以接受一个键值匹配的EnumMap或普通Map，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(EnumMap&lt;K, ? extends V&gt; m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(Map&lt;K, ? extends V&gt; m)</span></span></span><br></pre></td></tr></table></figure>

<p>比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Size,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">hashMap.put(Size.LARGE, <span class="number">2</span>);</span><br><span class="line">hashMap.put(Size.SMALL, <span class="number">1</span>);</span><br><span class="line">Map&lt;Size, Integer&gt; enumMap = <span class="keyword">new</span> EnumMap&lt;&gt;(hashMap);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>枚举</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2020/06/06/java/%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>注解(<code>Annotation</code>)也可以叫做元数据。是一种代码级别的说明。它是<code>jdk1.5</code>及以后引入的一个特性，与类，接口和枚举是在同一个层次，他可以声明在<strong>包、类、字段、方法、局部变量、方法参数</strong>等的前面，用来对这些元素进行说明，注释。</p>
<a id="more"></a>



<h1 id="作用分类"><a href="#作用分类" class="headerlink" title="作用分类"></a>作用分类</h1><h2 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h2><p>通过代码里的标识的注解让编译器能够实现基本的编译检查(比如说<code>OVerride</code>注解)</p>
<h2 id="编写文档"><a href="#编写文档" class="headerlink" title="编写文档"></a>编写文档</h2><p>通过代码里的标识的注解可以生成文档(<code>doc</code>文档)</p>
<p><strong>案例</strong></p>
<p>比如现在包结构和代码示例如下：</p>
<p><img src="/2020/06/06/java/%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3/image-20200225211527629.png" alt="image-20200225211527629"></p>
<p>现在想要生成<code>doc</code>文档到<code>doc目录</code>下，使用如下命令：</p>
<p><img src="/2020/06/06/java/%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3/image-20200225211734336.png" alt="image-20200225211734336"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc -sourcepath ./src/main/java -subpackages example -d ./src/doc -encoding UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>上面命令的意思是将<strong>源文件位置在</strong><code>./src/main/java</code>(这里使用了相对路径)并且<strong>子包</strong>为<code>example</code>里面的所有内容使用<code>utf-8</code>编码格式生成<code>doc</code>文档并且输出到<code>./src/doc</code>目录中</p>
<h3 id="参数查看"><a href="#参数查看" class="headerlink" title="参数查看"></a>参数查看</h3><p>具体参数可以使用 <code>javadoc -help</code>来查看</p>
<p><img src="/2020/06/06/java/%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3/image-20200225212001443.png" alt="image-20200225212001443"></p>
<p>生成中的结果如图所示</p>
<p><img src="/2020/06/06/java/%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3/image-20200225212401505.png" alt="image-20200225212401505"></p>
<p>可以看到和我们平时看到的<code>java api</code>是一样一样的。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>通过代码里标识的注解对代码进行分析(使用反射)</p>
<h1 id="jdk中预定义的注解"><a href="#jdk中预定义的注解" class="headerlink" title="jdk中预定义的注解"></a>jdk中预定义的注解</h1><h2 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h2><p>检测该注解标注的方法是否是继承自父类的方法，作用就是编译检查</p>
<h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h2><p>标注的方法代表是已经过时的方法</p>
<h2 id="SuppressWarning"><a href="#SuppressWarning" class="headerlink" title="@SuppressWarning"></a>@SuppressWarning</h2><ul>
<li>如果是放在类上就是压制类中所有的警告</li>
<li>如果是放在方法上就是压制该方法上的警告</li>
</ul>
<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><h2 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h2><p>注解格式包含两部分</p>
<ul>
<li>元注解</li>
<li><code>public @interface 注解名称{}</code></li>
</ul>
<p>注解本质上是一个接口，并且该接口继承了<code>Annotation</code>抽象类。</p>
<h2 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h2><p>所谓注解的属性也就是接口中的<strong>抽象方法</strong>。</p>
<p>为什么称为属性，请看使用案例：</p>
<p><strong>注解代码:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.one;</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnoOne &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">address</span><span class="params">()</span> <span class="keyword">default</span> "中国"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用注解代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.one;</span><br><span class="line"><span class="meta">@AnnoOne</span>(age=<span class="number">12</span>, name=<span class="string">"张三"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnoOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addTwoNum</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注解里面定义的方法在使用时方法名就相当于是一个属性一样来使用。所以才称之为是注解的属性。</p>
<h3 id="属性的返回值"><a href="#属性的返回值" class="headerlink" title="属性的返回值"></a>属性的返回值</h3><ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
<h3 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h3><ul>
<li>如果定义属性时，使用<code>default</code>关键字给属性默认初始值，则使用注解时可以不进行属性的赋值</li>
<li>如果<strong>只有一个属性</strong>需要赋值，并且属性的名称是<code>value</code>，则<code>value</code>可以省略，直接定义值即可</li>
<li>数组赋值时，值使用<code>{}</code>包裹，如果数组中只有一个值，那么<code>{}</code>可以省略不写。</li>
</ul>
<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>用于描述注解的注解</p>
<ul>
<li><p><code>@Target</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  描述注解能够作用的位置, <code>ElementType</code>是一个枚举，我们<strong>常用</strong>的是如下几个值：</p>
<ul>
<li><code>TYPE</code>： 表示这个注解可以作用到类上面</li>
<li><code>FILED</code>：表示这个注解可以作用到字段上面</li>
<li><code>METHOD</code>：表示这个注解可以作用到方法上</li>
</ul>
</li>
<li><p><code>@Retention</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  描述注解被保留的阶段,<code>RetentionPolicy</code>也是一个枚举，里面有三个值：</p>
<ul>
<li><code>SOURCE</code>：表示在源码阶段就起作用</li>
<li><code>CLASS</code>：表示在字节码阶段起作用</li>
<li><code>RUNTIME</code>：表示在运行时阶段起作用(对于我们自己编写的注解一般都是使用<code>RUNTIME</code>)</li>
</ul>
</li>
<li><p><code>@Document</code><br>  描述注解是否被抽取到<code>api</code>文档中</p>
</li>
<li><p><code>@Inherited</code></p>
<p>  描述注解是否被子类继承</p>
</li>
</ul>
<h1 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h1><h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p><a href="https://gitee.com/Gwei11/Java/tree/master/code/java-base/annotation" target="_blank" rel="noopener">案例地址</a></p>
<p>我们使用注解主要是为了获取在注解中定义的属性值，下面有一个案例，<strong>给定类名和方法名</strong>，通过反射的方式来调用这个方法。</p>
<h3 id="使用properties完成"><a href="#使用properties完成" class="headerlink" title="使用properties完成"></a>使用<code>properties</code>完成</h3><p>配置 <code>domethod.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">example.xml.DoReflectXmlMethod</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">show</span></span><br></pre></td></tr></table></figure>

<p>与配置文件对应的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.xml;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoReflectXmlMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这个方法是xml配置参数通过反射来完成的"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.xml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestXml</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xmlTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步加载properties</span></span><br><span class="line">        <span class="comment">//1.1创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//1.2加载配置文件，转换为一个集合</span></span><br><span class="line">        <span class="comment">//1.2.1获取class目录下的配置文件</span></span><br><span class="line">        ClassLoader classLoader = TestXml<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">"domethod.properties"</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line">        String className = pro.getProperty(<span class="string">"className"</span>);</span><br><span class="line">        String methodName = pro.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载该类进内存</span></span><br><span class="line">        Class aClass = Class.forName(className);</span><br><span class="line">        <span class="comment">// 创建对俩</span></span><br><span class="line">        Object o = aClass.newInstance();</span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        Method method = aClass.getMethod(methodName);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用注解完成"><a href="#使用注解完成" class="headerlink" title="使用注解完成"></a>使用注解完成</h3><p>注解类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.TYPE, ElementType.METHOD&#125;) <span class="comment">// 可以作用在方法和类上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">// 运行时起作用,这个注解不能少</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">className</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">methodName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与注解对应的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.anno;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnno</span>(className = <span class="string">"example.anno.DoReflectAnnoMethod"</span>, methodName = <span class="string">"show"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoReflectAnnoMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这个方法是anno配置参数通过反射来完成的"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnno</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annoTest</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取含有注解的那个类的字节码对象</span></span><br><span class="line">        Class&lt;DoReflectAnnoMethod&gt; testAnnoClass = DoReflectAnnoMethod<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获取注解对象，注解本质上是一个接口，该方法是在内存中有一个该接口的实现类</span></span><br><span class="line">        MyAnno annotation = testAnnoClass.getAnnotation(MyAnno<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行接口方法，获取注解属性值</span></span><br><span class="line">        String className = annotation.className();</span><br><span class="line">        String methodName = annotation.methodName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载该类进内存</span></span><br><span class="line">        Class aClass = Class.forName(className);</span><br><span class="line">        <span class="comment">// 创建对俩</span></span><br><span class="line">        Object o = aClass.newInstance();</span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        Method method = aClass.getMethod(methodName);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><p>一个简单的测试框架，测试方法的时候可能有很多方法，而且有的方法是不需要测试的，此时可以通过注解来标识那些方法是需要测试的，那些方法是不用测试的。</p>
<p><strong>自定义注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD) <span class="comment">// 该注解是作用方法上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">// 运行时使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要测试的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加了check注解的方法表示需要测试的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 + 1 ="</span> + (<span class="number">1</span> + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 - 0 ="</span> + (<span class="number">1</span> - <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mul</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 * 1 ="</span> + (<span class="number">1</span> * <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">de</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1 / 0 ="</span> + (<span class="number">1</span> / <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noException</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"该方法没有异常不用测试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个需要类中有很多方法需要测试，区分标准就是方法上如果有<code>@Check</code>注解就表示需要测试</p>
<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取对象</span></span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="comment">// 获取字节码文件</span></span><br><span class="line">        Class&lt;? extends Calculator&gt; aClass = calculator.getClass();</span><br><span class="line">        <span class="comment">// 获取所有方法</span></span><br><span class="line">        Method[] methods = aClass.getMethods();</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;<span class="comment">//出现异常的次数</span></span><br><span class="line">        <span class="comment">// 记录异常的文件</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bug.txt"</span>));</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">// 判断方法上是否具有check注解</span></span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(Check<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 有注解，则要执行该方法进行测试</span></span><br><span class="line">                    method.invoke(calculator);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 有异常则记录异常</span></span><br><span class="line">                    <span class="comment">//记录到文件中</span></span><br><span class="line">                    number++;</span><br><span class="line">                    bw.write(method.getName() + <span class="string">" 方法出异常了"</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"异常的名称:"</span> + e.getCause().getClass().getSimpleName());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"异常的原因:"</span> + e.getCause().getMessage());</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                    bw.write(<span class="string">"--------------------------"</span>);</span><br><span class="line">                    bw.newLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bw.write(<span class="string">"本次测试一共出现 "</span>+number+<span class="string">" 次异常"</span>);</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面测试代码其实就是利用反射的只是来获取方法上的注解，如果包含<code>@Check</code>则需要执行测试方法，否则不用执行。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>idea下编译spring源码</title>
    <url>/2020/06/06/tools/idea/idea%E4%B8%8B%E7%BC%96%E8%AF%91spring%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>步骤</p>
<ol>
<li>下载<code>spring</code>源码</li>
<li>切换阿里云的源</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">	repositories &#123;</span><br><span class="line">		maven &#123; url <span class="string">'https://maven.aliyun.com/nexus/content/groups/public/'</span> &#125;</span><br><span class="line">		maven&#123; url <span class="string">'https://maven.aliyun.com/nexus/content/repositories/jcenter'</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tools</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>idea中springMVC项目热部署</title>
    <url>/2020/06/06/tools/idea/idea%E4%B8%ADspringMVC%E9%A1%B9%E7%9B%AE%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="设置项目未运行时自动编译"><a href="#设置项目未运行时自动编译" class="headerlink" title="设置项目未运行时自动编译"></a>设置项目未运行时自动编译</h1><p><img src="idea%E4%B8%ADspringMVC%E9%A1%B9%E7%9B%AE%E7%83%AD%E9%83%A8%E7%BD%B2.images/image-20200308080024577.png" alt="image-20200308080024577"></p>
<p>勾上标红的部分。</p>
<h1 id="设置项目运行时自动编译"><a href="#设置项目运行时自动编译" class="headerlink" title="设置项目运行时自动编译"></a>设置项目运行时自动编译</h1><p>按下快捷键<code>ctrl+shift+alt+/</code>选择<code>Registry</code></p>
<p><img src="idea%E4%B8%ADspringMVC%E9%A1%B9%E7%9B%AE%E7%83%AD%E9%83%A8%E7%BD%B2.images/image-20200308080213753.png" alt="image-20200308080213753"></p>
<h1 id="设置tomcat"><a href="#设置tomcat" class="headerlink" title="设置tomcat"></a>设置tomcat</h1><p>部署的时候选择带有<code>exploded</code>的那个<code>war</code>包</p>
<blockquote>
<ol>
<li>war模式：将WEB工程以包的形式上传到服务器 ；</li>
<li>war exploded模式：将WEB工程以当前文件夹的位置关系上传到服务器(这个包可以认为是没有压缩的)</li>
</ol>
</blockquote>
<p><img src="idea%E4%B8%ADspringMVC%E9%A1%B9%E7%9B%AE%E7%83%AD%E9%83%A8%E7%BD%B2.images/image-20200308080812456.png" alt="image-20200308080812456"></p>
<p>然后如图所示，需要将标红的两个位置都修改成<code>update classes and resources</code>，如果上一步部署的时候选择的是不带有<code>exploded</code>，那么这里<code>On update action</code>是不会有<code>Update classes and resources</code>这个选择的。</p>
<h1 id="以debug模式启动"><a href="#以debug模式启动" class="headerlink" title="以debug模式启动"></a>以debug模式启动</h1><p>经过亲自使用，发现上面的都配置以后，如果没有以<code>debug</code>模式启动的话，那些<code>jsp，js</code>等资源确实是可以自动更新，但是<code>java</code>文件修改后没有自动更新，所以需要以<code>debug</code>模式启动，不过尝试的结果是不仅仅要以<code>debug</code>模式启动，还需要在修改的地方去打上断点，以调试的模式走过修改部分的代码才起了作用。</p>
]]></content>
      <categories>
        <category>tools</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>idea中web项目部署的问题</title>
    <url>/2020/06/06/tools/idea/idea%E4%B8%ADweb%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="idea中对于web项目的配置"><a href="#idea中对于web项目的配置" class="headerlink" title="idea中对于web项目的配置"></a>idea中对于web项目的配置</h1><p>对于一个<code>web</code>项目需要配置<code>facets</code>，如下图所示</p>
<p><img src="idea%E4%B8%ADweb%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%9A%84%E9%97%AE%E9%A2%98.images/image-20200307125001685.png" alt="image-20200307125001685"></p>
<p><code>facets</code>是<code>idea</code>中的配置，</p>
<p>还有一个是<code>Artifacts</code>,这个是<code>maven</code>中的概念，如果想要将项目部署到<code>tomcat</code>中就需要<code>Artifacts</code></p>
<p><img src="idea%E4%B8%ADweb%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%9A%84%E9%97%AE%E9%A2%98.images/image-20200307125225987.png" alt="image-20200307125225987"></p>
<p><img src="idea%E4%B8%ADweb%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%9A%84%E9%97%AE%E9%A2%98.images/image-20200307125259694.png" alt="image-20200307125259694"></p>
<p>在选择的时候可以看到有两个可以选择，其中一个是含有<code>exploded</code>，另外一个没有，那么他们有什么区别呢，其实可以认为不带有<code>exploded</code>就是压缩 的，而带有<code>exploded</code>是 没有压缩的文件。</p>
<blockquote>
<ol>
<li>war模式：将WEB工程以包的形式上传到服务器 ；</li>
<li>war exploded模式：将WEB工程以当前文件夹的位置关系上传到服务器(这个包可以认为是没有压缩的)</li>
</ol>
</blockquote>
<p>而对于<code>Artifacts</code>如果没有添加我们也是可以自己添加的。如下图所示。</p>
<p><img src="idea%E4%B8%ADweb%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%9A%84%E9%97%AE%E9%A2%98.images/image-20200307125641865.png" alt="image-20200307125641865"></p>
]]></content>
      <categories>
        <category>tools</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>idea工具</title>
    <url>/2020/06/06/tools/idea/idea%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="idea中不能创建jsp文件解决方式"><a href="#idea中不能创建jsp文件解决方式" class="headerlink" title="idea中不能创建jsp文件解决方式"></a>idea中不能创建jsp文件解决方式</h1><p>在<code>idea</code>中对于一个<code>web</code>项目有时候在<code>webapp/WEB-INF</code>下右键创建<code>jsp</code>文件时并没有该选项。如图所示：</p>
<p><img src="/2020/06/06/tools/idea/idea%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/1582116203351.png" alt="1582116203351"></p>
<p>实际上<code>idea</code>工具是可以创建<code>jsp</code>文件的，之所以不能创建出来是因为没有正确设置，设置方式如下：</p>
<p><img src="/2020/06/06/tools/idea/idea%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/1582116427213.png" alt="1582116427213"></p>
<p>然后将<code>Web Resource directory path</code>设置到<code>webapp</code>目录那一级。</p>
<p><img src="/2020/06/06/tools/idea/idea%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/1582116490022.png" alt="1582116490022"></p>
<p>此时再去新增<code>jsp</code>文件</p>
<p><img src="/2020/06/06/tools/idea/idea%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/1582116582608.png" alt="1582116582608"></p>
<p>可以看到<code>webapp</code>那个目录其实已经换了图标，并且其下面的所有目录都可以新增<code>jsp</code>文件了。</p>
<h1 id="idea中将代码抽取中一个单独的方法"><a href="#idea中将代码抽取中一个单独的方法" class="headerlink" title="idea中将代码抽取中一个单独的方法"></a>idea中将代码抽取中一个单独的方法</h1><ul>
<li>首先选中需要抽取的代码，然后如下图所示进行操作</li>
</ul>
<p><img src="idea%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.images/image-20200303091909902.png" alt="image-20200303091909902"></p>
<p>也可以进行右键后选择<code>Refactor-&gt;Extract</code>进行操作</p>
<h1 id="idea实现自动编译"><a href="#idea实现自动编译" class="headerlink" title="idea实现自动编译"></a>idea实现自动编译</h1><p><img src="idea%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.images/image-20200304204529707.png" alt="image-20200304204529707"></p>
<p>此时会发现项目会即时编译，如果出现错误下面的图中位置会有提示</p>
<p><img src="idea%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.images/image-20200304204622116.png" alt="image-20200304204622116"></p>
<h1 id="springBean的autowire的报错问题"><a href="#springBean的autowire的报错问题" class="headerlink" title="springBean的autowire的报错问题"></a>springBean的autowire的报错问题</h1><p>使用下面的配置即可。</p>
<p><img src="idea%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.images/image-20200304204916822.png" alt="image-20200304204916822"></p>
<h1 id="idea中使用eclipse的格式化插件"><a href="#idea中使用eclipse的格式化插件" class="headerlink" title="idea中使用eclipse的格式化插件"></a>idea中使用eclipse的格式化插件</h1><p>下载插件的<a href="https://blog.csdn.net/java_lifeng/article/details/90754099" target="_blank" rel="noopener">地址</a>，就是搜索<code>eclipse code formatter</code>即可，下载完之后配置地址如下</p>
<p><img src="idea%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.images/image-20200316204323402.png" alt="image-20200316204323402"></p>
<h1 id="idea中使用gradle编译spring源码很慢的问题解决方式"><a href="#idea中使用gradle编译spring源码很慢的问题解决方式" class="headerlink" title="idea中使用gradle编译spring源码很慢的问题解决方式"></a>idea中使用gradle编译spring源码很慢的问题解决方式</h1><p><a href="https://blog.csdn.net/AARON0797/article/details/104424462" target="_blank" rel="noopener">参考地址</a></p>
<h1 id="idea解决控制台中文乱码问题"><a href="#idea解决控制台中文乱码问题" class="headerlink" title="idea解决控制台中文乱码问题"></a>idea解决控制台中文乱码问题</h1><p><a href="https://blog.csdn.net/qq_39136928/article/details/81240894" target="_blank" rel="noopener">参考地址</a></p>
<h1 id="idea配置"><a href="#idea配置" class="headerlink" title="idea配置"></a>idea配置</h1><h2 id="idea去掉编辑区的竖线，打开方法分割线"><a href="#idea去掉编辑区的竖线，打开方法分割线" class="headerlink" title="idea去掉编辑区的竖线，打开方法分割线"></a>idea去掉编辑区的竖线，打开方法分割线</h2><p><img src="/2020/06/06/tools/idea/idea%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/image-20200531104309971.png" alt="image-20200531104309971"></p>
]]></content>
      <categories>
        <category>tools</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>maven使用手册</title>
    <url>/2020/06/06/tools/maven/maven/</url>
    <content><![CDATA[<h1 id="maven配置默认的jdk版本"><a href="#maven配置默认的jdk版本" class="headerlink" title="maven配置默认的jdk版本"></a><code>maven</code>配置默认的jdk版本</h1><p>在<code>maven</code>的安装目录下修改<code>settings.xml</code>文件，修改内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个节点需要加载在<code>profiles</code>节点下。</p>
<a id="more"></a>]]></content>
      <categories>
        <category>tools</category>
        <category>maven</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>maven</tag>
      </tags>
  </entry>
</search>
