<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo</title>
    <url>/2020/04/22/hexo/hexo/</url>
    <content><![CDATA[<h1 id="文章目录默认展开"><a href="#文章目录默认展开" class="headerlink" title="文章目录默认展开"></a>文章目录默认展开</h1><p><a href="https://blog.csdn.net/wugenqiang/article/details/88609066" target="_blank" rel="noopener">参考文章</a></p>
<p>对于想要通过点击目录来进行展开与收缩的，需要进行下面的操作，把</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;文章目录默认展开</span><br><span class="line">.post-toc .nav .nav-child &#123; display: block; &#125;</span><br></pre></td></tr></table></figure>

<p>里面的<code>.nav-child</code>去掉即可通过点击来实现目录的展开与收缩。</p>
<a id="more"></a>

<h1 id="新建菜单以及添加菜单图标"><a href="#新建菜单以及添加菜单图标" class="headerlink" title="新建菜单以及添加菜单图标"></a>新建菜单以及添加菜单图标</h1><p><a href="http://theme-next.iissnan.com/getting-started.html#menu-settings" target="_blank" rel="noopener">next官网</a></p>
<p>在官网中查看主题设定-&gt;菜单那部分，当我们新添加一个菜单是(比如我要添加阅读)，在<code>next</code>的配置文件中(<code>_config.yml</code>)里面找到下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  book: &#x2F;book || book #这里是新添加的菜单</span><br><span class="line"></span><br><span class="line"># Enable&#x2F;Disable menu icons.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: tru</span><br><span class="line">  book: book（这里是图标）</span><br></pre></td></tr></table></figure>

<p>然后在开启的对应的语言文件中，比如我使用的是中文，那么就是在<code>zh-Hans.yml</code>文件中找到<code>menu</code>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br><span class="line">  <span class="attr">book:</span> <span class="string">阅读</span></span><br></pre></td></tr></table></figure>

<p>后面的book那一栏是后来添加的。需要注意的是在上面的第一个配置文件中所写的<code>book</code>是<a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a>中<code>icon</code>的名称，这样才可以在我们自己的页面显示出图标。</p>
<h1 id="添加社交功能之邮箱"><a href="#添加社交功能之邮箱" class="headerlink" title="添加社交功能之邮箱"></a>添加社交功能之邮箱</h1><p>在next主题配置文件搜索social:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:1744709138@qq.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br></pre></td></tr></table></figure>

<p>这里只是显示了邮箱，这些原来都是注释掉的，自己去掉前面的注释即可，需要注意的是邮箱前面的<code>mailto</code>是必须要保留的，还有最后面的<code>envelope</code>则是图标名字，也是不能修改的。</p>
<h1 id="友情链接的配置"><a href="#友情链接的配置" class="headerlink" title="友情链接的配置"></a>友情链接的配置</h1><p>在<code>next</code>主题配置文件中查找标签<code>links</code>并进行如下配置:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># title</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">Links</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">MacTalk:</span> <span class="string">http://macshuo.com/</span></span><br><span class="line">  <span class="attr">Title:</span> <span class="string">http://example.com/</span></span><br></pre></td></tr></table></figure>

<h1 id="实现聊天功能"><a href="#实现聊天功能" class="headerlink" title="实现聊天功能"></a>实现聊天功能</h1><p><a href="https://hoxis.github.io/hexo-next-daovoice.html" target="_blank" rel="noopener">查看转载文章</a></p>
<h1 id="添加近期文章展示"><a href="#添加近期文章展示" class="headerlink" title="添加近期文章展示"></a>添加近期文章展示</h1><p><a href="https://blog.csdn.net/wugenqiang/article/details/88581218" target="_blank" rel="noopener">查看转载文章</a></p>
<h1 id="显示文章的更新时间"><a href="#显示文章的更新时间" class="headerlink" title="显示文章的更新时间"></a>显示文章的更新时间</h1><p>在主题的配置文件中找到<code>updated_at</code>，然后将其值修改为<code>true</code>即可(这种方式应该是适用于5以后的版本)</p>
<p>对于以前的方式可以看这篇<a href="https://blog.csdn.net/ganzhilin520/article/details/79053399" target="_blank" rel="noopener">别人写的文章</a></p>
<h1 id="字数统计与阅读时长"><a href="#字数统计与阅读时长" class="headerlink" title="字数统计与阅读时长"></a>字数统计与阅读时长</h1><p><a href="https://www.cnblogs.com/php-linux/p/8418518.html" target="_blank" rel="noopener">查看转载文章</a></p>
<h1 id="添加版权信息"><a href="#添加版权信息" class="headerlink" title="添加版权信息"></a>添加版权信息</h1><p>在站点配置文件搜索<code>post_copyright</code>，将<code>enable</code>修改为<code>true</code>，添加<code>author</code>即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">3.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/3.0/</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">咖啡杯里的茶</span></span><br></pre></td></tr></table></figure>

<h1 id="修改文章底部的标签"><a href="#修改文章底部的标签" class="headerlink" title="修改文章底部的标签"></a>修改文章底部的标签</h1><p>修改模板 <code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h1 id="修改博客的背景图"><a href="#修改博客的背景图" class="headerlink" title="修改博客的背景图"></a>修改博客的背景图</h1><p>在<code>themes-&gt;next-&gt;source-&gt;css-&gt;_custom-&gt;custom.styl</code>添加如下的代码:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//背景图</span><br><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(https://i.loli.net/<span class="number">2019</span>/<span class="number">05</span>/<span class="number">02</span>/<span class="number">5</span>ccab829cdad9.jpg);</span><br><span class="line">    background-attachment: fixed; // 不随屏幕滚动而滚动fixed,scroll,inherit</span><br><span class="line">    background-repeat: no-repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺</span><br><span class="line">    background-size: cover; // contain等比例铺满屏幕 //cover拉伸铺满</span><br><span class="line">    background-position: bottom;//x,y轴调整</span><br><span class="line">    +<span class="selector-tag">mobile</span>()&#123;</span><br><span class="line">      //background-position: 0% -20%;https://i.loli.net/2019/05/02/5ccab829cdad9.jpg</span><br><span class="line">      //https://i.loli.net/2018/12/29/5c270fc2bfcad.png</span><br><span class="line">      background-image: url(https://i.loli.net/2019/05/02/5ccab829cdad9.jpg);</span><br><span class="line">      <span class="selector-tag">background-size</span>: <span class="selector-tag">cover</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面几个有<code>url</code>的地方换成自己想要使用的背景图的图片的外链地址即可。</p>
<h1 id="将文章归类到新建的菜单中"><a href="#将文章归类到新建的菜单中" class="headerlink" title="将文章归类到新建的菜单中"></a>将文章归类到新建的菜单中</h1><p>比如自己已经添加了新的菜单<code>book</code>，现在想要将新建的文章归类到<code>book</code>这个菜单下做法如下：</p>
<p>在menu下如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">    home: / || home</span><br><span class="line">    tags: /tags/ || tags</span><br><span class="line">    categories: /categories/ || th</span><br><span class="line">    archives: /archives/ || archive</span><br><span class="line">    book: categories/book || book</span><br></pre></td></tr></table></figure>

<p>最后一个book是我自己新建的分类。然后再写文章时添加如下头部信息:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">title: abc</span><br><span class="line">categories:</span><br><span class="line">  - book</span><br></pre></td></tr></table></figure>

<p>这样当你点击<code>book</code>那个菜单时就会先显示<code>abc</code>这篇文章。</p>
<p><a href="https://www.cnblogs.com/codebook/p/10312965.html" target="_blank" rel="noopener">参考链接</a></p>
<h1 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h1><p><a href="https://www.jianshu.com/p/ea78bdd0551f" target="_blank" rel="noopener">显示图片</a></p>
<h1 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h1><p><a href="https://blog.csdn.net/qq_40265501/article/details/80030627" target="_blank" rel="noopener">添加搜索</a></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>githubPag自定义域名以及两台电脑使用hexo</title>
    <url>/2020/04/22/hexo/githubPags/</url>
    <content><![CDATA[<h1 id="githubPag自定义域名"><a href="#githubPag自定义域名" class="headerlink" title="githubPag自定义域名"></a>githubPag自定义域名</h1><p><a href="https://blog.csdn.net/heimu24/article/details/81159099" target="_blank" rel="noopener">查看文章</a></p>
<a id="more"></a>

<h1 id="多台电脑使用hexo"><a href="#多台电脑使用hexo" class="headerlink" title="多台电脑使用hexo"></a>多台电脑使用hexo</h1><h2 id="不修改主题"><a href="#不修改主题" class="headerlink" title="不修改主题"></a>不修改主题</h2><p><a href="https://blog.csdn.net/ShmilyCoder/article/details/79916973" target="_blank" rel="noopener">查看文章</a></p>
<p>需要注意的是如果后续只是写博客而没有修改主题等文件的话只需使用hexo分支来操作即可。</p>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>如果需要修改主题的话依然是需要在搭建博客的电脑上搭建博客的那个目录(<code>hexo</code>)，使用两台电脑来写博客时都是使用的是后来创建的分支，此时修改主题则是在博客搭建目录里面去修改，修改完之后直接在博客搭建目录使用<code>git bash</code>，然后通过<code>hexo clean</code>， <code>hexo d -g</code>, 将修改的主题发布出去，但是此时需要注意的是当我们发布之后再去访问自己的博客发现文章可能会少很多，这很正常，因为我们后来写的博客都是在创建的分支上面去写的，最开始创建博客的那个目录并没有维护起来，此时看到的博客其实是最开始创建博客的那个目录里面的文章，所以此时只需要将修改的那部分主题文件拷贝到我们的分支目录对应位置，然后提交并且在在分支目录里面重新<code>hexo clean</code>， <code>hexo d -g</code>一次就可以了。以后只要不修改主题文件就都是在分支上操作了，只要需要修改主题文件时才需要在最开始创建博客的那个目录去操作然后拷贝到分支上并提交。</p>
<p><font color="green">我们创建博客的那个目录并不是一个<code>repository</code>，所以在那个目录是不能使用git命令的，只是我们将其余github进行了关联而已，所以在那里面只能使用hexo命令。</font></p>
<p><font color="red">经过测试，不是非要在创建博客的那台上脑上该样式才有作用，实际上在另外的一台电脑上直接修改样式也是有效果的。</font></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java中boolean类型属性定义为什么不要使用is开头</title>
    <url>/2020/04/23/java/base/java%E4%B8%ADboolean%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81is%E5%BC%80%E5%A4%B4/</url>
    <content><![CDATA[<h1 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h1><p><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/success-isSuccess-and-bollean-Bollean" target="_blank" rel="noopener">参考地址</a></p>
<a id="more"></a>

<h1 id="boolean和Boolean类型属性不使用is开头"><a href="#boolean和Boolean类型属性不使用is开头" class="headerlink" title="boolean和Boolean类型属性不使用is开头"></a>boolean和Boolean类型属性不使用is开头</h1><p>看下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> setterproperty;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanProperty</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAaa;</span><br><span class="line">    <span class="keyword">private</span> Boolean bbb;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isCcc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ddd;</span><br><span class="line">    <span class="keyword">private</span> String isEee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIsEee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsEee</span><span class="params">(String isEee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isEee = isEee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getAaa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAaa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAaa</span><span class="params">(Boolean aaa)</span> </span>&#123;</span><br><span class="line">        isAaa = aaa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getBbb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bbb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBbb</span><span class="params">(Boolean bbb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bbb = bbb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCcc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isCcc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCcc</span><span class="params">(<span class="keyword">boolean</span> ccc)</span> </span>&#123;</span><br><span class="line">        isCcc = ccc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ddd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDdd</span><span class="params">(<span class="keyword">boolean</span> ddd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ddd = ddd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了<strong>三类</strong>， <strong>五个</strong>属性，并且生成了<code>set</code>和<code>get</code>方法</p>
<ul>
<li><code>Boolean</code>类型，属性分别带有<code>is</code>开头和不带有<code>is</code>开头（包装类）</li>
<li><code>boolean</code>类型，属性分别带有<code>is</code>开头和不带有<code>is</code>开头（基本类型）</li>
<li><code>string</code>类型，属性分别带有<code>is</code>开头和不带有<code>is</code>开头</li>
</ul>
<p>上面的<code>set</code>和<code>get</code>方法是<code>idea</code>自动生成的，可以看到对于<code>Boolean</code>以及<code>boolean</code>类型的属性，如果是以<code>is</code>开头的，那么在生成<code>set</code>方法的时候不是在前面加上<code>set</code>，而是直接使用<code>is</code>开头，对于其他类型的值没有影响。</p>
<h1 id="Boolean和boolean的区别"><a href="#Boolean和boolean的区别" class="headerlink" title="Boolean和boolean的区别"></a>Boolean和boolean的区别</h1><p>看一下阿里巴巴<code>java</code>开发手册中对于基本类型和包装类型的使用标准</p>
<p><img src="/2020/04/23/java/base/java%E4%B8%ADboolean%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81is%E5%BC%80%E5%A4%B4/640.jpeg" alt="img"></p>
<p>其实也很容易理解，因为基本数据类型都是有默认值的，但是包装数据类型没有默认值。所以程序如果使用基本类型，那么有可能不是我们想要的结果，但是由于有默认值，程序并没有抛出异常，但是结果不对（对于结果不对时不应该使用默认值计算，而是应该我们自己处理）。若使用包装类型，当程序返回<code>null</code>的时候就说明此时结果已经是不对的，需要我们自己去处理。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java中有疑惑的问题</title>
    <url>/2020/04/22/java/base/java%E4%B8%AD%E6%9C%89%E7%96%91%E6%83%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="java中为什么只有值传递-没有引用传递"><a href="#java中为什么只有值传递-没有引用传递" class="headerlink" title="java中为什么只有值传递,没有引用传递"></a>java中为什么只有值传递,没有引用传递</h1><p><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/why-pass-by-reference" target="_blank" rel="noopener">参考地址</a></p>
<h1 id="为什么java中byte类型的取值范围是-128到127"><a href="#为什么java中byte类型的取值范围是-128到127" class="headerlink" title="为什么java中byte类型的取值范围是-128到127"></a>为什么<code>java</code>中<code>byte</code>类型的取值范围是-128到127</h1><p><a href="https://blog.csdn.net/qq_23418393/article/details/57421688" target="_blank" rel="noopener">参考地址</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存模型</title>
    <url>/2020/04/24/java/jvm/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="java内存模型-java-memory-mode"><a href="#java内存模型-java-memory-mode" class="headerlink" title="java内存模型(java memory mode)"></a>java内存模型(java memory mode)</h1><p><code>java</code>内存模型实际上是一个抽象的概念，是一套规范，而不是一个实际的东西，而<code>java</code>内存结构就是根据这一套规范来进行划分的。可以先看另一篇文章。</p>
<p><a href="https://gwei11.gitee.io/2020/04/23/java/jvm/jvm/#more" target="_blank" rel="noopener">jvm</a></p>
<a id="more"></a>

<h2 id="什么是java内存模型-JMM规范"><a href="#什么是java内存模型-JMM规范" class="headerlink" title="什么是java内存模型(JMM规范)"></a>什么是<code>java</code>内存模型(JMM规范)</h2><p><code>jvm</code>将内存组织结构主要划分为两个部分</p>
<ul>
<li>主内存</li>
<li>工作内存</li>
</ul>
<h3 id="主内存"><a href="#主内存" class="headerlink" title="主内存"></a>主内存</h3><ul>
<li>主要包含本地方法区和堆</li>
<li>所有变量都要存储在主内存中，这些变量对于所有线程都是共享的</li>
</ul>
<h3 id="工作内存"><a href="#工作内存" class="headerlink" title="工作内存"></a>工作内存</h3><ul>
<li>每一个线程都是自己独立工作的地方，也就是工作内存</li>
<li>工作内存中保存的是主内存中某些变量的拷贝，线程堆变量的所有操作都必须在工作内存中进行，不能直接操作主内存</li>
<li><strong>如果是基本数据类型，那么直接分配到工作内存，如果是引用类型，引用的地址存在在工作空间中，但是具体的对象是存在在堆中(也就是主内存中)，是可以共享的</strong></li>
</ul>
<p><img src="/2020/04/24/java/jvm/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20200423233046759.png" alt="什么是java内存模型"></p>
<p>看上图，之所以存在<code>java</code>内存模型一说是因为<code>java</code>虚拟机的工作机制。当有多个线程的时候，每一个线程可以操作的数据有两种类型</p>
<ul>
<li>线程私有的数据，也就是这个数据就算改变了也不会影响其余线程，比如说局部变量就是线程私有的数据</li>
<li>线程共享的数据，这样的数据多个线程都可以访问，就会出现线程安全的问题</li>
</ul>
<p>因为线程操作的数据有不同类型，所以在<code>java</code>中一个线程去操作数据的时候不是在主内存中直接操作，其实还有一个属于线程自己的内存(工作内存)，当操作线程私有的数据比较好理解，直接在工作内存中完成就可以咯，如果是操作共享的数据，那么就在主内存中拿一份数据到自己工作内存中操作，操作完了再将数据给到主内存中。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的集合</title>
    <url>/2020/04/23/java/base/java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java中自动拆装箱和缓存机制</title>
    <url>/2020/04/22/java/base/java%E4%B8%AD%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> automaticpacking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPackage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自动装箱</span></span><br><span class="line">        Integer i = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 自动拆箱</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="两种方式查看自动拆装箱的代码"><a href="#两种方式查看自动拆装箱的代码" class="headerlink" title="两种方式查看自动拆装箱的代码"></a>两种方式查看自动拆装箱的代码</h2><h3 id="反编译法"><a href="#反编译法" class="headerlink" title="反编译法"></a>反编译法</h3><p>将上面的代码使用<code>javap</code>命令反编译一下：</p>
<p><img src="/2020/04/22/java/base/java%E4%B8%AD%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/image-20200422224048061.png" alt="image-20200422224048061"></p>
<p>可以看到其实自动拆装箱是通过<code>Integer.valueOf()</code>和<code>Integer.intValue()</code></p>
<h3 id="调试法"><a href="#调试法" class="headerlink" title="调试法"></a>调试法</h3><p>上面是通过反编译的形式可以知道底层调用的代码是什么，其实中<code>idea</code>中还有一种方式是断点调试</p>
<p><img src="/2020/04/22/java/base/java%E4%B8%AD%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/image-20200422225116752.png" alt="image-20200422225116752"></p>
<p>可以看到上面的图片，可以点击<code>force step into</code>来进入代码。</p>
<h4 id="step-into-和-force-step-into的区别"><a href="#step-into-和-force-step-into的区别" class="headerlink" title="step into 和 force step into的区别"></a><code>step into</code> 和 <code>force step into</code>的区别</h4><ul>
<li><code>step into</code>可以进入自己写的方法内部去调试</li>
<li><code>force step into</code>可以进入任何方法内部进行调试，由于这里我们是要进入<code>jdk</code>的包内部代码进行调试，所以需要使用<code>force step into</code></li>
</ul>
<h1 id="Integer类型的缓存问题"><a href="#Integer类型的缓存问题" class="headerlink" title="Integer类型的缓存问题"></a>Integer类型的缓存问题</h1><p>看下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> automaticpacking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPackage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">100</span>;</span><br><span class="line">        Integer j = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">200</span>;</span><br><span class="line">        Integer j2 = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">int</span> j3 = <span class="number">300</span>;</span><br><span class="line">        System.out.println(i == j); <span class="comment">// true</span></span><br><span class="line">        System.out.println(i2 == j2); <span class="comment">// false</span></span><br><span class="line">        System.out.println(i3 == j3); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码输出个结果是不是有点奇怪， 第二个结果和第三个结果还是比较号理解的</p>
<ul>
<li>基本类型的比较肯定比较值就可以咯。所以输出结果为<code>true</code>没有疑问</li>
<li>包装类型为什么第一个是<code>true</code>，第二个是<code>false</code>呢</li>
</ul>
<h2 id="Integer类型缓存值"><a href="#Integer类型缓存值" class="headerlink" title="Integer类型缓存值"></a>Integer类型缓存值</h2><p>我们通过调试法看下 <code>Integer i = 100</code>这句代码是如何执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">      <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看源码就知道 <code>IntegerCache.low</code>固定为-128</li>
<li><code>IntegerCache.high</code>是可以配置的，看下源码注释<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>，所以可以通过这个参数类配置最大值。</li>
</ul>
<h2 id="包装类型的比较的坑"><a href="#包装类型的比较的坑" class="headerlink" title="包装类型的比较的坑"></a>包装类型的比较的坑</h2><p>上面只是分析了<code>Integer</code>类型，其实还有其他包装类型也是一样的有缓存的值，所以对于包装类型有一点需要知道，<strong>包装类型的比较最好都通过<code>equals</code>方法来进行比较</strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>动态代理和使用jdk自带的HSDB查看被代理的类的代码</title>
    <url>/2020/04/22/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://gitee.com/Gwei11/code/tree/master/javabase/proxy/proxy-demo" target="_blank" rel="noopener">动态代理示例代码</a></p>
<h1 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h1><p>所谓的代理模式简单理解就是对原有的功能增强的一种模式。代理模式有三个角色：    </p>
<ul>
<li>接口(<code>Subject</code>)   </li>
<li>委托类(<code>RealSubject</code>),该类也是真正实现功能的类    </li>
<li>代理类(<code>ProxySubject</code>)这个代理类对我们的委托类进行增强处理 </li>
</ul>
<a id="more"></a>

<h1 id="动态代理分类"><a href="#动态代理分类" class="headerlink" title="动态代理分类"></a>动态代理分类</h1><h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p><code>jdk</code>动态代理的的核心是主要是有两个类</p>
<ul>
<li><code>Proxy</code>类的<code>newProxyInstance</code>方法</li>
<li><code>InvocationHandler</code> 接口</li>
</ul>
<h3 id="jdk动态代理案例"><a href="#jdk动态代理案例" class="headerlink" title="jdk动态代理案例"></a><code>jdk</code>动态代理案例</h3><ul>
<li>一个接口</li>
<li>该接口的实现类</li>
<li>一个实现了<code>InvocationHandler</code> 接口的处理类</li>
</ul>
<p><strong>接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dynamicProxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NeedProxyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dynamicProxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedProxyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">NeedProxyInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现了<code>InvocationHandler</code> 接口的处理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dynamicProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    NeedProxyInterface needProxyInterface = <span class="keyword">new</span> NeedProxyInterfaceImpl();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">111</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(needProxyInterface, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dynamicProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NeedProxyInterface object =</span><br><span class="line">               (NeedProxyInterface)Proxy.newProxyInstance(NeedProxyInterface<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                new Class[]&#123;NeedProxyInterface.class&#125;, new MyInvocationHandler());</span><br><span class="line">        object.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以根据下面介绍的使用方式使用<code>HSDL</code>工具生成代理类文件，生成的文件内容如下：</p>
<p><strong>代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dynamicProxy.NeedProxyInterface;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">NeedProxyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m4 = Class.forName(<span class="string">"com.dynamicProxy.NeedProxyInterface"</span>).getMethod(<span class="string">"sayHello"</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.dynamicProxy.NeedProxyInterface"</span>).getMethod(<span class="string">"add"</span>, Integer.TYPE, Integer.TYPE);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="/2020/04/22/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422211307163.png" alt="image-20200422211307163"></p>
<p>其实我们之所以不懂代理，是因为这个代理类生成后是在内存中的，如果我们能看到这样的一个类的代码就不会觉得难，所以可以使用上面所说的<code>HSDL</code>工具将代理类下载下来就比较容易看懂。</p>
<h1 id="使用HSDL工具查看代理类代码"><a href="#使用HSDL工具查看代理类代码" class="headerlink" title="使用HSDL工具查看代理类代码"></a>使用HSDL工具查看代理类代码</h1><h2 id="找到jdk当中的sa-jdi-jar的位置"><a href="#找到jdk当中的sa-jdi-jar的位置" class="headerlink" title="找到jdk当中的sa-jdi.jar的位置"></a>找到<code>jdk</code>当中的<code>sa-jdi.jar</code>的位置</h2><p>比如在我的电脑上这个<code>jar</code>包的位置</p>
<p><img src="/2020/04/22/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422210719406.png" alt="image-20200422210719406"></p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>执行如下所示的命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\&gt;java -classpath <span class="string">"D:\installpackage\programme\java\jdk1.8\lib\sa-jdi.jar"</span> sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure>

<p>执行完成之后会出现一个窗口</p>
<p><img src="/2020/04/22/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422210835780.png" alt="image-20200422210835780"></p>
<h2 id="运行jsp命令找到进程ID"><a href="#运行jsp命令找到进程ID" class="headerlink" title="运行jsp命令找到进程ID"></a>运行jsp命令找到进程ID</h2><p><img src="/2020/04/22/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422210909216.png" alt="image-20200422210909216"></p>
<p>将这里找到的进程ID输入到上面第一步的位置，然后进行如下截图所示操作：</p>
<p><img src="/2020/04/22/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422210922005.png" alt="image-20200422210922005"></p>
<p><img src="/2020/04/22/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422210937056.png" alt="image-20200422210937056"></p>
<p>如上图所示，因为案例中<code>cglib</code>代理的是<code>Producer</code>，所以这里我们搜索<code>Producer</code>，可以看到下面有一个类就是<code>Producer</code>，还有一个是<code>cglib</code>的代理类，我们点击那个<code>cglib</code>的代理类</p>
<p><img src="/2020/04/22/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422211017916.png" alt="image-20200422211017916"></p>
<p>点击之后会出现上图所示界面，点击<code>create.class file</code>即可</p>
<p><img src="/2020/04/22/java/proxy/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20200422211044414.png" alt="image-20200422211044414"></p>
<p>我们可以根据这个代理类的名称来找到生成的这个代理类在哪里（<strong>默认的位置和我们运行cmd的路径有关，比如上面我是在D盘根目录中运行的cmd命令，所以创建的代理类的位置就是在D盘根目录然后加上这个类的包路径</strong>）。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>proxy</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载器</title>
    <url>/2020/04/23/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><ul>
<li><p>将<code>java</code>源代码经过编译器编译器<code>class</code>字节码文件</p>
<ul>
<li><code>java</code>文件和<code>class</code>文件都是在本次磁盘中</li>
</ul>
</li>
<li><p>将字节码文件加载进内存，并且在内存中创建对象的<code>class</code>对象，这个过程称之为类的加载</p>
<p>  一个类的生命周期从类被加载、连接和初始化开始，只有在虚拟机内存中，我们的<code>java</code>程序才可以使用它。</p>
</li>
</ul>
<p><img src="/2020/04/23/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301102806401.png" alt="image-20200301102806401"></p>
<a id="more"></a>

<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类的加载是由类加载器完成的，类加载器可以分为两种</p>
<ul>
<li>第一种是<code>java</code>虚拟机自带的类加载器<ul>
<li>根类加载器(<code>Bootstrap</code>)</li>
<li>扩展类加载器(<code>Extension</code>)</li>
<li>系统了加载器</li>
</ul>
</li>
<li>第二种是用户自定义的类加载器<ul>
<li>自定义类加载器是<code>java.lang.ClassLoader</code>的子类实例</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/23/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301095942835.png" alt="image-20200301095942835"></p>
<h2 id="根类加载器"><a href="#根类加载器" class="headerlink" title="根类加载器"></a>根类加载器</h2><ul>
<li>根类加载器是最底层的类加载器，是虚拟机的一部分，没有父类，也没有继承<code>java.lang.ClassLoader</code></li>
<li>主要负责<code>&lt;JAVA_HOME&gt;/jre/lib</code>下的核心类库</li>
<li>处于安全考虑，根类加载器只能加载<code>java</code>、<code>javax</code>、<code>sun</code>开头的类</li>
</ul>
<h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h2><ul>
<li>扩展类加载器是指由原<code>SUN</code>公司实现的<code>sun.misc.Launcher</code>类</li>
<li>该类加载器是由<code>java</code>语言编写，父类加载器是根类加载器</li>
<li>负责加载<code>&lt;JAVA_HOME&gt;/jre/lib/ext</code>目录下的类库或者系统变量<code>“java.ext.dirs”</code>指定的目录下的类库。</li>
</ul>
<h2 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h2><ul>
<li>系统类加载器也称之为应用类加载器，也是纯<code>java</code>类</li>
<li>系统类加载器的父类加载器是扩展类加载器</li>
<li>负责加载<code>classpath</code>环境变量或系统属性<code>java.class.path</code>所指定的目录中加载类</li>
<li>应用类加载器是用户自定义的类加载器的默认父加载器，一般情形下，该类加载器是程序中默认的类加载器，可以通过<code>ClassLoader.getSystemClassLoader()</code>直接获取</li>
</ul>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><ul>
<li>除了虚拟机自带的根类加载器之外，其余的类家在重庆都有自己唯一的父加载器</li>
<li>当需要使用类加载器加载一个类时，该<code>classLoder</code>会先委托自己的父家在重庆去加载这个类，如果父类加载器可以加载，则由父类加载器去加载。否则才是<code>classLoader</code>自己去加载这个类</li>
<li>双亲委派机制的父子关系和面向对象程序设计中的继承关系是不一样的，而是通过使用组合模式来复用父类加载器。</li>
</ul>
<p><img src="/2020/04/23/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301111621578.png" alt="image-20200301111621578"></p>
<h2 id="双亲委派模式的好处"><a href="#双亲委派模式的好处" class="headerlink" title="双亲委派模式的好处"></a>双亲委派模式的好处</h2><ul>
<li>可以避免类的重复加载，当父类加载器已经加载了该类时，就没有必要让子<code>ClassLoader</code>再去加载一次</li>
<li>考虑到安全因素，<code>java</code>核心<code>api</code>中定义的类型不会被随意替换<ul>
<li>比如自己定义了一个<code>java.lang.Object</code>的类，通过双亲委托模式传递到启动类加载器，启动类加载器在核心<code>api</code>中发现了这个名字的类，发现已经被加载，这样就不会重新加载，而是直接返回已经加载过的<code>Object.class</code>，这样就可以防止核心<code>api</code>被随意篡改。</li>
</ul>
</li>
</ul>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码的包名是<code>java.lang</code>，由于<code>java</code>的核心<code>api</code>的包名也是这个，所以运行上面的成出现下面的错误</p>
<p><img src="/2020/04/23/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301112618193.png" alt="image-20200301112618193"></p>
<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><p><code>ClassLoader</code>中主要看这个方法</p>
<h2 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先检查该类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">          <span class="comment">// 还没加载的类才会继续加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果有父类加载器就让父类去加载</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// 没有父类就使用根类加载器去加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">               		<span class="comment">// 如果父类加载器或根类加载器都没有加载到，就使用自己的类加载器去加载</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name)</span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>laodClass</code>方法中体现了双亲委托模式的逻辑<ul>
<li>首先让父类加载器加载</li>
<li>父类加载器没有加载到就让根类加载器加载</li>
<li>父类或根类加载器都没有加载到的时候就使用自己的类加载器加载</li>
</ul>
</li>
</ul>
<h2 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>findClass</code>默认是一个错误的空实现，<strong>这也是我们自定义类加载器时需要重写的方法。</strong></p>
<h2 id="defineCLass"><a href="#defineCLass" class="headerlink" title="defineCLass"></a>defineCLass</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                         ProtectionDomain protectionDomain)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是用来将<code>byte[]</code>字节解析成虚拟机能够识别的<code>class</code>对象，<code>defineClass</code>通常和<code>findClass</code>方法一起使用，在自定义类加载器时，会直接覆盖<code>CLassLoader</code>的<code>findCLass</code>方法获取想要加载类的字节码，然后调用<code>defineCLass</code>方法生成<code>Class</code>对象。</p>
<h2 id="resolveCLass"><a href="#resolveCLass" class="headerlink" title="resolveCLass"></a>resolveCLass</h2><p>连接指定的类，类加载器可以使用此方法来连接类。</p>
<h1 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h1><p>在<code>java.net</code>包中。<code>jdk</code>提供了一个类加载器<code>URLClassLoader</code>，该类扩展了<code>ClassLoader</code>，能够从本地或网络</p>
<p>上指定的位置加载类，我们也可以使用该类作为自定义的类加载器使用。</p>
<p>其构造器中只要需要传入<code>URL</code>地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls)</span> </span>&#123;&#125;<span class="comment">// 使用默认的父类构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent)</span> </span>&#123;&#125; <span class="comment">// 也可以自己指定构造器</span></span><br></pre></td></tr></table></figure>



<p><strong>测试案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.loader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestURLClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载本地的类</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOne</span> <span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"d:/"</span>);</span><br><span class="line">        URI uri = file.toURI();</span><br><span class="line">        URL url = uri.toURL();</span><br><span class="line">        URLClassLoader urlClassLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        Class&lt;?&gt; aClass = urlClassLoader.loadClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        aClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载网络上的类</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTwo</span> <span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost:8080/examples/"</span>);</span><br><span class="line">        URLClassLoader urlClassLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        Class&lt;?&gt; aClass = urlClassLoader.loadClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        aClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加载本地的类</strong></p>
<p>在我的本地<code>d</code>盘根目录中有一个 <code>TestClassLoader.java</code>文件，文件内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoader</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestClassLoader</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"new Instance"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时使用<code>javac</code>命令来编译一下：</p>
<p><code>javac -d . TestClassLoader.java</code></p>
<p><img src="/2020/04/23/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301131544718.png" alt="image-20200301131544718"></p>
<p><img src="/2020/04/23/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301131633046.png" alt="image-20200301131633046"></p>
<ul>
<li><code>-d</code>选项是指定编译到哪里去的位置</li>
<li><code>.</code>点是指当前目录</li>
</ul>
<p>执行加载本地的类的代码会输出  <code>new Instance</code></p>
<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>上面已经说过，想要自定义类加载器，有如下几个固定步骤</p>
<ul>
<li>自定义的类需要继承<code>ClassLoader</code>抽象类</li>
<li>重写<code>findCLass</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.loader;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被加载的类所在的目录</span></span><br><span class="line">    <span class="keyword">private</span> String directory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义类加载器需要重写该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//    将类名转换为目录</span></span><br><span class="line">            String file = directory + File.separator + name.replace(<span class="string">"."</span>, File.separator) + <span class="string">".class"</span>;</span><br><span class="line">            <span class="comment">// 构建输入流</span></span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">// 构建字节输出流</span></span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="comment">// 定义缓冲区</span></span><br><span class="line">            <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 往输出流中输入数据</span></span><br><span class="line">                baos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//读取到的字节码二进制数据</span></span><br><span class="line">            <span class="keyword">byte</span> data[] = baos.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// main方法测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"d:/"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = myClassLoader.loadClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        System.out.println(aClass.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="热部署类加载器"><a href="#热部署类加载器" class="headerlink" title="热部署类加载器"></a>热部署类加载器</h1><p><strong>所谓的热部署就是让同一个<code>class</code>可以被不同的类加载器加载即可。</strong></p>
<p>当我们使用<code>loadClass</code>方法加载类时，会采用双亲委托模式。</p>
<ul>
<li>如果一个类已经被加载，加一次加载该类时就会从缓存中取，不会重新加载</li>
<li>如果同一个<code>class</code>被同一个类加载器加载多次，则会报错</li>
</ul>
<p>而<code>ClassLoader</code>中实现委托机制的代码主要在<code>loadClass</code>方法，而真正实现加载的则是<code>findClass</code>方法，所以我们只需要不调用<code>loadClass</code>方法而直接调用<code>findClass</code>就可以实现同一个类被不同的类加载器加载。</p>
<p><strong>案例代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.loader;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"D:/"</span>);</span><br><span class="line">        MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(classLoader,<span class="string">"D:/"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass1 = classLoader1.loadClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        System.out.println(aClass.hashCode()); <span class="comment">// 1364335809</span></span><br><span class="line">        System.out.println(aClass1.hashCode());<span class="comment">// 1364335809</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"D:/"</span>);</span><br><span class="line">        MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(classLoader,<span class="string">"D:/"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = classLoader.findClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass1 = classLoader1.findClass(<span class="string">"example.TestClassLoader"</span>);</span><br><span class="line">        System.out.println(aClass.hashCode()); <span class="comment">// 233530418</span></span><br><span class="line">        System.out.println(aClass1.hashCode()); <span class="comment">// 683287027</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了上面自定义类加载器的代码。</p>
<ul>
<li>第一个测试案例中两个<code>class</code>的<code>hashCode</code>是一致的，说明类加载器的双亲委托机制起了作用</li>
<li>第二个测试案例中虽然第一个类加载器也是第二类加载器的父类加载器，但是两个类的<code>hashCode</code>并不是一样的，这说明，这两个类加载器都起了作用，这是因为这里没有使用<code>loadClass</code>方法，所以双亲委托机制的代码就没有起到作用。</li>
</ul>
<h1 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h1><p>对于使用<code>JDBC</code>的时候我们都知道，第一步就是要注册驱动,对于<code>mysql</code>而言如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/23/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301142454190.png" alt="image-20200301142454190"></p>
<p>但是实际上即使我们没有写这样的一句代码，其余的代码也是可以正常执行的。那来看一下<code>DriverManager</code>类的代码：</p>
<p><img src="/2020/04/23/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301143318867.png" alt="image-20200301143318867"></p>
<p>在第2步里面有两种方式来注册该驱动</p>
<p><strong>来看2.1中实现类加载的方式</strong></p>
<p><code>2.1</code>的代码跟到第4步的时候可以看到下面这样的一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>Thread.currentThread().getContextClassLoader()</code>，也就是获取<strong>线程上下文类类加载器</strong>，在线程启动的时候应用类加载器会默认赋值给当前线程，所以<code>getContextClassLoader</code>方法默认情况下获取的也是应用类加载器。</p>
<p><strong>看2.2的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">"DriverManager.Initialize: loading "</span> + aDriver);</span><br><span class="line">                Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                        ClassLoader.getSystemClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                println(<span class="string">"DriverManager.Initialize: load failed: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里面使用到了<code>Class.forName(aDriver, true,  ClassLoader.getSystemClassLoader())</code></p>
<p>对于<code>ClassLoader.getSystemClassLoader()</code>方法获取的是<strong>系统应用类加载器</strong>，所以这里其实是破坏了双亲委托模式，因为<code>DriverManager</code>是启动项加载器来加载的(也就是根类加载器)，而在<code>DriverManager</code>中使用系统类加载器去加载数据库驱动包的类。</p>
<p>还有一个点需要注意，在2.2代码中使用到了<code>aDriver</code>这个变量，该变量来源</p>
<p><img src="/2020/04/23/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301144304571.png" alt="image-20200301144304571"></p>
<p>也就是从<code>jdbc.drivers</code>文件中去加载，其余这里是使用到了<code>SPI</code>机制</p>
<h2 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h2><blockquote>
<p><code>SPI</code> ，全称为 <code>Service Provider Interface</code>，是一种服务发现机制。它通过在<code>ClassPath</code>路径下的<code>META-INF/services</code>文件夹查找文件，自动加载文件里所定义的类.</p>
</blockquote>
<p>可以看一下<code>Mysql</code>驱动包里面确实有有这样的一个文件</p>
<p><img src="/2020/04/23/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20200301144534613.png" alt="image-20200301144534613"></p>
<p>对于使用<code>SPI</code>机制使用到的类是  <code>ServiceLoader</code>。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm</title>
    <url>/2020/04/23/java/jvm/jvm/</url>
    <content><![CDATA[<h1 id="什么是jvm"><a href="#什么是jvm" class="headerlink" title="什么是jvm"></a>什么是jvm</h1><p><code>java Virtual Machine</code>也就是<code>java</code>程序运行的环境(<code>java</code>二进制字节码的运行环境)</p>
<h2 id="使用jvm的优势"><a href="#使用jvm的优势" class="headerlink" title="使用jvm的优势"></a>使用jvm的优势</h2><ul>
<li><p>使用<code>java</code>的程序员都知道，<code>java</code>是一次编写，处处运行的，那么为什么可以做到一次编写，处处运行呢？</p>
<p>  <a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/platform-independent" target="_blank" rel="noopener">java是如何实现平台无关的</a></p>
</li>
<li><p>自动内存管理，有垃圾回收功能</p>
</li>
</ul>
<a id="more"></a>

<h2 id="jdk、jre、jvm的区别"><a href="#jdk、jre、jvm的区别" class="headerlink" title="jdk、jre、jvm的区别"></a><code>jdk</code>、<code>jre</code>、<code>jvm</code>的区别</h2><p><img src="/2020/04/23/java/jvm/jvm/image-20200423222219450.png" alt="image-20200423222219450"></p>
<h1 id="jvm的内存结构"><a href="#jvm的内存结构" class="headerlink" title="jvm的内存结构"></a>jvm的内存结构</h1><p><code>java</code>内存结构主要划分为五大部分</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><code>Program Counter Register</code>程序计数器(寄存器)</p>
<p><img src="/2020/04/23/java/jvm/jvm/image-20200423222321549.png" alt="image-20200423222321549"></p>
<p>如上图所示：<code>java</code>源代码到生成对象是有一个过程的</p>
<ol>
<li><code>java</code>源文件首先需要经过编译器编译成字节码<code>.class</code>文件，字节码文件中其实就是一条条的<code>jvm</code>指令，这些指令是不能直接到<code>cpu</code>中执行的，所以需要第二步。</li>
<li>第二步这些字节码的<code>jvm</code>指令会被解释器解释成<strong>机器码</strong></li>
<li>机器码可以直接被<code>cpu</code>识别并执行</li>
<li>要知道指令不是只有一条，那么当执行完这一条指令后，如何知道下一条要执行的是什么指令呢？此时就需要 使用到<strong>程序计数器</strong>，<strong>程序计数器的作用就是保存程序需要执行的下一条<code>jvm</code>指令.</strong></li>
<li>程序计数器的物理实现是寄存器.</li>
</ol>
<h3 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h3><ul>
<li>线程私有</li>
<li>唯一一个不会存在内存溢出的区域</li>
</ul>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ul>
<li>栈是<strong>线程</strong>运行时需要的内存空间</li>
<li>栈的组成元素叫做栈帧<ul>
<li>每一个方法的运行所需要的内存就是一个栈帧</li>
</ul>
</li>
<li>每一个线程只能有一个活动栈帧，对应着当前线程正在执行的那个方法</li>
</ul>
<p>所以方法的代码，局部变量那些都是保存在栈中。</p>
<h3 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h3><h4 id="垃圾回收是否涉及栈内存"><a href="#垃圾回收是否涉及栈内存" class="headerlink" title="垃圾回收是否涉及栈内存"></a>垃圾回收是否涉及栈内存</h4><p>栈内存涉及到的是方法调用，当方法调用完成后方法对应的栈帧就会自动出栈，所以也不存在垃圾回收的问题。</p>
<h4 id="栈内存是否分配的越大越好"><a href="#栈内存是否分配的越大越好" class="headerlink" title="栈内存是否分配的越大越好"></a>栈内存是否分配的越大越好</h4><p>当栈内存分配的越大，也就你意味着能够容纳的栈帧就越多，栈帧越多对应的是方法调用的层级可以更深，但是由于内存总容量是固定的，所以当栈内存越大的时候，同时可以运行的线程的数量就会减少(原因可以看上面栈内存的说明，要知道栈是线程运行时需要的内存空间)</p>
<h4 id="方法内的局部变量是否线程安全"><a href="#方法内的局部变量是否线程安全" class="headerlink" title="方法内的局部变量是否线程安全"></a>方法内的局部变量是否线程安全</h4><p>考虑线程安全的问题需要考虑的一个变量是线程私有的，还是线程共享的，当是线程私有的时候就不会有线程安全的问题，当时线程共享的时候就会有线程安全的问题。</p>
<ul>
<li>如果方法内的局部变量没有逃离方法的作用范围，就是线程安全的</li>
<li>如果局部变量引用了对象，并逃离了方法 的作用范围，就是线程不安全的</li>
</ul>
<h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><ul>
<li>栈帧<strong>过多</strong>会导致栈内存溢出(也就是方法调用层级过多)</li>
<li>栈帧<strong>过大</strong>导致栈内存溢出</li>
<li>栈内存溢出会出现<code>java.lang.StackOverflowError</code>错误</li>
<li>在<code>idea</code>中我们可以自己设置栈的大小来进行测试， 设置参数 为 <code>-Xss256k</code>（<code>-Xss</code>固定，字面的数值自己设置）</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul>
<li>当<code>java</code>虚拟机 调用本地方法的时候需要提供的内存空间</li>
<li>带有<code>native</code>修饰的方法就是本地方法</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul>
<li>通过<code>new</code>关键字创建的对象，都会使用堆内存(但是现在已经有技术可以避过这个问题，所以现在这句话也不绝对)</li>
<li>堆是线程共享的，堆中对象都需要考虑线程安全的问题</li>
<li>有垃圾回收机制</li>
</ul>
<h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.heap;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">// -Xmx8m  可以使用-Xmx来修改堆内存大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">"hello"</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<p><img src="/2020/04/23/java/jvm/jvm/image-20200423223432569.png" alt="image-20200423223432569"></p>
<ul>
<li>可以通过 <code>-Xmx8m</code>来将堆内存的大小设置为<code>8m</code>，这样再一次运行循环次数肯定会降低。</li>
</ul>
<h3 id="堆内存诊断工具"><a href="#堆内存诊断工具" class="headerlink" title="堆内存诊断工具"></a>堆内存诊断工具</h3><ul>
<li><code>jps</code>工具<ul>
<li>查看当前系统中有哪些<code>java</code>进程</li>
</ul>
</li>
<li><code>jmap</code>工具<ul>
<li>查看某一个时刻堆内存占用情形</li>
</ul>
</li>
<li><code>jconsole</code>工具<ul>
<li>图形界面，多功能的检测工具，可以连续检测</li>
</ul>
</li>
</ul>
<h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p><strong>注：</strong>下面我所有的命令都是在<code>idea</code>的<code>terminal</code>窗口执行的，其实只要配置了jdk环境变量，就可以在任意位置开启<code>cmd</code>窗口来执行也是一样的。</p>
<p>该工具的作用是查看当前系统中有那些<code>java</code>进程。就拿上面的案例代码来看，该命令是在<code>idea</code>中<code>local</code>窗口输入的。</p>
<p><img src="/2020/04/23/java/jvm/jvm/image-20200423223652867.png" alt="image-20200423223652867"></p>
<p>使用<code>jps</code>命令可以查看到当前程序的进程<code>id</code>是8152</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>方法区主要存储的是类结构的，也就是类的一些信息，比如下面的一些信息<ul>
<li>构造方法</li>
<li>成员方法</li>
<li>成员变量</li>
<li>运行时常量池</li>
</ul>
</li>
<li>方法区在虚拟机启动的时候就会创建</li>
<li>方法区在<strong>逻辑上</strong>是堆内存的一部分，但是实际上不一定是，比如对于<code>HotSpot</code>虚拟机在<code>jdk1.8</code>方法区使用<strong>永久代</strong>来实现，确实是堆空间的一部分，但是<code>jdk1.8</code>及以后使用的是<strong>元空间</strong>来实现，使用的是系统内存。</li>
<li>方法区也会导致<code>OutOfMemory</code>错误</li>
</ul>
<p><img src="/2020/04/23/java/jvm/jvm/image-20200423223835220.png" alt="image-20200423223835220"></p>
<h3 id="jdk1-6方法区的内存结构"><a href="#jdk1-6方法区的内存结构" class="headerlink" title="jdk1.6方法区的内存结构"></a>jdk1.6方法区的内存结构</h3><p><img src="/2020/04/23/java/jvm/jvm/image-20200423223943229.png" alt="image-20200423223943229"></p>
<h3 id="jdk1-8方法区的内存结构"><a href="#jdk1-8方法区的内存结构" class="headerlink" title="jdk1.8方法区的内存结构"></a>jdk1.8方法区的内存结构</h3><p><img src="/2020/04/23/java/jvm/jvm/image-20200423224013817.png" alt="image-20200423224013817"></p>
<h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><ul>
<li><p><code>jdk1.8</code>之前会出现永久代内存溢出</p>
<ul>
<li>出现<code>java.lang.OutOfMemoryError:PermGen space</code></li>
<li>可以通过 <code>-XX:MaxPermsize=8m</code>  来设置方法区大小</li>
</ul>
</li>
<li><p><code>jdk1.8</code>之后会导致元空间内存溢出</p>
<ul>
<li>出现<code>java.lang.OutOfMemoryError:Metaspace</code></li>
<li>可以通过<code>-XX:MetaspaceSize=8m</code>来设置方法区大小</li>
</ul>
</li>
</ul>
<h3 id="二进制字节码"><a href="#二进制字节码" class="headerlink" title="二进制字节码"></a>二进制字节码</h3><p>二进制字节码中主要包含了三个内容</p>
<ul>
<li>类的基本信息</li>
<li>常量池</li>
<li>类方法定义(类方法定义中包含了虚拟机指令)</li>
</ul>
<p>可以通过反编译来查看主体是不是包含这三个部分</p>
<p><strong>源代码DemoOne.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对DemoOne.class反编译</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javap -v 类名.class</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/23/java/jvm/jvm/image-20200423224155411.png" alt="image-20200423224155411"></p>
<p><strong>反编译后的内容</strong></p>
<p><strong><img src="/2020/04/23/java/jvm/jvm/image-20200229090947417-1587653003528.png" alt="image-20200229090947417"></strong></p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>从上图可以看出方法定义中包含了<code>jvm</code>指令，<code>jvm</code>指令后可以看到有<code>#1</code>、<code>#2</code>这样的内容，这些就需要到常量池找对应的信息，就可以得知需要执行的是什么代码。</p>
<p><strong>常量池</strong></p>
<blockquote>
<p>常量池就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p>
</blockquote>
<p><strong>运行时常量池</strong></p>
<blockquote>
<p>常量池是二进制字节码（*.class）文件中的,当该类被加载到内存中，它的常量池信息就会放入到运行时常量池中，并且把里面的符号地址转换为真实地址。</p>
</blockquote>
<h4 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h4><p><code>StringTable</code>也就是我们平时所说的串池，当我们定义一个<strong>字符串常量</strong>时，实际上有以下几步：注意这里说的是字符串常量才是这种操作</p>
<ol>
<li>在串池中查找该字符串<ol>
<li>找到了直接返回该字符串</li>
<li>没有找到则创建一个字符串<ol>
<li>将创建的<strong>字符串常量</strong>放入到串池中</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong><code>StringTable</code>的特性</strong></p>
<ul>
<li>常量池中的字符串仅仅是符号，第一次使用时才会变为对象</li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li><strong>字符串变量</strong>的拼接原理是<code>StringBuilder</code>(jdk1.8)</li>
<li><strong>字符串常量</strong>的拼接原理是编译器优化</li>
<li>可以使用<code>intern</code>方法。主动将串池中还没有的字符串对象放入到串池<ul>
<li>对于jdk1.7及以后<ul>
<li><code>intern</code>方法会尝试将这个对象放入串池，如果有则不会放入，如果没有则放入串池，最终会将串池中的对象返回</li>
</ul>
</li>
<li>对于jdK1.6<ul>
<li><code>intern</code>方法会尝试将这个对象放入串池，如果有则不会放入，如果没有则<strong>拷贝一份放入串池</strong>，但是调用的这个对象是不会被放入到串池中，最终会将串池中的对象返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><p><img src="/2020/04/23/java/jvm/jvm/image-20200229095538249.png" alt="案例"></p>
<ul>
<li>上面截图中 <code>String ab1 = a + b</code>在字节码层面实际上是使用的<code>StringBuilder</code>来拼接，最后使用<code>toString</code>方法，实际上是在堆中新建了一个字符串对象</li>
<li><code>String ab2 = &quot;a&quot; + &quot;b&quot;</code>,由于新增的都是常量，所以会在编译器直接拼接中<code>ab</code>,而<code>ab</code>在串池中已经存在，所以<code>ab2</code>这个<code>ab</code>会直接从串池中拿。</li>
</ul>
<h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a><strong>案例2</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableDemo2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">// intern方法会尝试将这个对象放入串池，如果有则不会放入，如果没有则放入串池，最终会将串池中的对象返回</span></span><br><span class="line">        String s2 = s.intern();</span><br><span class="line">        System.out.println(s == <span class="string">"ab"</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s2 == <span class="string">"ab"</span>); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ab = <span class="string">"ab"</span>;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">// intern方法会尝试将这个对象放入串池，如果有则不会放入，如果没有则放入串池，最终会将串池中的对象返回</span></span><br><span class="line">        String s2 = s.intern();</span><br><span class="line">        System.out.println(s == ab); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s2 == ab); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>one方法分析</strong></p>
<ul>
<li><code>new Sring(&quot;a&quot;)</code>实际上有两个操作<ul>
<li>将<code>&quot;a&quot;</code>字符串常量放入到<code>StringTable</code>中</li>
<li>在堆中创建一个字符串对象<code>&quot;a&quot;</code></li>
</ul>
</li>
<li><code>new String(&quot;b&quot;)</code>同样的也是有两个操作<ul>
<li>将<code>&quot;b&quot;</code>字符串常量放入到<code>StringTable</code>中</li>
<li>在堆中创建一个字符串对象<code>&quot;b&quot;</code></li>
</ul>
</li>
<li><code>String s2 = s.intern();</code><ul>
<li><code>s</code>是值为<code>&quot;ab&quot;</code>的字符串对象，该字符串对象存在堆中，<code>StringTable</code>中并没有，所以<code>intern</code>方法会将<code>s</code>指向的对象放入到<code>StringTable</code>中，并且返回<code>StringTable</code>中的对象，因此<code>s</code>和<code>s2</code>都是指向<code>StringTable</code>中<code>&quot;ab&quot;</code>的对象，因此比较的结果都是<code>true</code></li>
</ul>
</li>
</ul>
<p><strong>two方法分析</strong></p>
<ul>
<li><code>two</code>方法与<code>one</code>方法不同之处在于先创建了<code>&quot;ab&quot;</code>字符串常量，所以<code>StringTable</code>中存在<code>&quot;ab&quot;</code>.</li>
<li><code>String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code>这一句和<code>one</code>方法的解析是一样的，<code>s</code>一个指向堆内存中值为<code>&quot;ab&quot;</code>的对象</li>
<li><code>String s2 = s.intern();</code>由于<code>StringTable</code>中已经存在<code>&quot;ab&quot;</code>，所以<code>s</code>对象不会被放入到<code>StringTable</code>中，但是返回的依然是<code>StringTable</code>中的对象，所以比较结果一个是<code>false</code>,一个是<code>true</code></li>
</ul>
<h4 id="StringTable的位置"><a href="#StringTable的位置" class="headerlink" title="StringTable的位置"></a><strong>StringTable的位置</strong></h4><ul>
<li><code>jdk1.6</code>中<code>StringTable</code>存在于永久代中</li>
<li><code>jdk1.8</code>中<code>StringTable</code>存在于堆中</li>
</ul>
<p><strong>验证jdk1.8</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.method;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">// 需要设置堆的大小  -Xmx10m</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableDemo3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200000</span>; j++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                list.add(String.valueOf(j).intern());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于堆空间很大，所以可以设置虚拟机运行参数来控制堆的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx10m</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/23/java/jvm/jvm/image-20200229110457271.png" alt></p>
<p>出现<code>GC overhead limit exceeded</code>，此时还需要添加一个参数来关闭这种限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:-UseGCOverheadLimit</span><br></pre></td></tr></table></figure>

<p>此时再去执行会出现如下图所示的错误，可以看到是堆空间不足。</p>
<p><img src="/2020/04/23/java/jvm/jvm/image-20200229111044049.png" alt></p>
<p><strong>验证jdk1.6</strong></p>
<p>首先通过虚拟机参数来控制永久代大小，下面是控制成<code>5m</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:MaxPermSize&#x3D;5m</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/23/java/jvm/jvm/image-20200229111447635.png" alt></p>
<p>然后运行上面的代码，可以看到报如下错误</p>
<p><img src="/2020/04/23/java/jvm/jvm/image-20200229111632554.png" alt></p>
<h5 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h5><ul>
<li><code>StringTable</code>底层使用的是<code>HashTable</code>来实现的</li>
<li>如果<code>StringTable</code>中字符串很多，可以通过 <code>-XX:StringTableSize=桶个数</code><ul>
<li>桶个数越大，每一个桶里面装的内容越少，每一个桶里面查找的数据就快，所以我们可以将这个数变大一点</li>
</ul>
</li>
<li>对于需要操作的数据有很多的重复性字符串，那么就可以考虑将这些字符串入池，这样可以减少内存占用</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>在<code>java</code>中调用<code>native</code>方法时实际上执行的部分消耗的内存不是<code>java</code>内存，而是本机的内存，这样当我们调用<code>native</code>方法时其实存在两块内存之间的交互，也就是说当<code>native</code>方法执行完后需要将结果从本地内存复制到<code>java</code>内存中才可以使用，而所谓的直接内存是引入一种<strong>基于通道与缓冲区</strong>的<code>I/O</code>方式，它可以使用<code>native</code>函数库直接分配堆外内存，然后通过一个存储在<code>java</code>堆里面的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作，这样就可以避免在<code>java</code>堆内存和<code>native</code>堆中来回复制数据。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>常见于<code>NIO(NO-Blocking IO)</code>,也就是非阻塞的<code>IO</code>操作，用于数据缓冲区。</li>
<li>分配会回收成本比较高，但是读写性能高</li>
<li>不受<code>JVM</code>内存回收管理</li>
<li>对于直接内存的回收实际上使用的是<code>java</code>中<code>unsafe</code>对象的<code>freeMemory</code>方法来回收而不是通过垃圾回收操作的。</li>
</ul>
<p><strong>java的io操作</strong></p>
<p><img src="/2020/04/23/java/jvm/jvm/image-20200229113833612.png" alt></p>
<ul>
<li>用户操作<code>java</code>程序</li>
<li><code>java</code>程序调用<code>native</code>方法间接调用系统方法操作磁盘中的文件<ul>
<li>系统读取文件时有系统缓冲区</li>
<li><code>java</code>中定义的缓冲区从系统缓冲区中拿出数据</li>
</ul>
</li>
</ul>
<p><strong>使用直接内存操作</strong></p>
<p><img src="/2020/04/23/java/jvm/jvm/image-20200229114102103.png" alt></p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>当我们思考<code>GC</code>(<code>Garbage Collection</code>)是需要思考三件事情：</p>
<ol>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<p>内存结构中的<strong>程序计数器</strong>，<strong>虚拟机栈</strong>，<strong>本地方法栈</strong>三个区域是随着线程而生的，栈中的栈帧随着方法进入和退出执行入栈和出栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来的时候就已经知道的(虽然在运行期间会由<code>JIT</code>编译器进行一些优化，不过大体上可以认为在编译期间就知道需要分配多少内存)，程序计数器是唯一个没有规定内存泄漏的区域，所以这几个区域是不用考虑内存回收的问题。<code>java</code>堆和方法区不一样，一个接口中多个实现类需要的内存可能不同，一个方法中的多个分支需要的内存也不一样，我们只有在程序处于运行的时候才知道需要创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的就是这部分内存(<strong>堆内存</strong>)。</p>
<h2 id="如何判断垃圾可以回收"><a href="#如何判断垃圾可以回收" class="headerlink" title="如何判断垃圾可以回收"></a>如何判断垃圾可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0<br>的对象就是不可能再被使用的。</p>
<p>但是<code>java</code>虚拟机不是使用这种方式来判断的，因为这种方式比较难以解决的一个问题就是<strong>循环引用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 该成员变量的作用是占用一点内存，可以在gc日志中判断对象是否被回收过</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">    ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">    objA.instance = objB;</span><br><span class="line">    objB.instance = objA;</span><br><span class="line">    objA = <span class="keyword">null</span>;</span><br><span class="line">    objB = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 下面的代码执行后，如果是通过引用计数法来判断对象是否可以回收的话，这两个对象是不会被回收的</span></span><br><span class="line">    System.gc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/23/java/jvm/jvm/1574560215250.png" alt="1574560215250"></p>
<p>如上图所示，即使执行了<code>objA = null</code>和<code>objB=null</code>,但是实际上他们的实例还是存在者引用，如果按照引用计数法来判断话，这两个对象是不会被回收的，实际上这两个对象是被回收了。所以可以说明<code>java</code>虚拟机不是使用引用计数法来判断对象是否可回收的。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>该算法的基本思路是通过一系列的称为<code>GC Root</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径中称为引用链，当一个对象到<code>GC Root</code>没有任何引用链时(从图论的角度来看，就是从<code>GC Root</code>到这个对象不可达)证明这个对象是不可用的。</p>
<ul>
<li><code>java</code>虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li>
<li>扫描堆中的对象，看是否能够沿着<code>GC Root</code>对象为起点的引用链找到该对象，如果找不到，表示可以回收。</li>
</ul>
<p>在<code>java</code>语法中，可作为<code>GC Root</code>的对象包含以下几种：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中<code>JNI</code>(也就是<code>native</code>方法)中引用的对象。</li>
</ul>
<h4 id="不可达不一定死亡"><a href="#不可达不一定死亡" class="headerlink" title="不可达不一定死亡"></a>不可达不一定死亡</h4><p>即使是在可达性分析算法中不可达的对象，也不一定都是要被回收的，此时他们暂时处于缓刑阶段，要宣告一个对象死亡，至少需要经历<strong>两次标记过程</strong></p>
<ul>
<li>如果对象在进行可达性分析后发现没有与<code>GC Root</code>相连接的引用链，那么将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，当对象没有覆盖<code>finalize()</code>方法时，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这两种情形视为<strong>“没有必要执行”</strong></li>
<li>如果该对象判断为有必要执行<code>finalize()</code>方法，那么该对象将中被放置在一个叫做<code>F-Queue</code>队列中，并且在稍后由一个虚拟机自动建立的，优先级低的<code>Finalizer</code>线程去执行它。<code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后<code>GC</code>将对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果对象在<code>finalize()</code>中成功拯救自己(只要重新与引用链上的任何一个对象建立关联即可，比如将自己(<code>this</code>关键字)赋值给某个类变量或对象的成员变量，那么在第二次标记的时候会被将它移除“<strong>即将回收</strong>”的集合)，如果对象在此时还没有逃脱，那就说明需要被回收了。</li>
</ul>
<p><font color="red">注意：这种自救方式并不被推荐，最好不要使用这个方法</font></p>
<h3 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h3><ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用(存放直接内存地址，便于回收直接内存)</li>
<li>终结器引用</li>
</ul>
<blockquote>
<ul>
<li>软引用和弱引用可以联合引用队列来使用，也可以不结合引用队列来使用(之所以需要结合引用队列来使用，是引用软引用和弱引用自身也是需要占有一定的内存的，要想回收他们就需要在引用队列中找到他们才能回收)<ul>
<li>当发生GC时不一定就与回收软引用，只有当发生GC之后内存还是不足的时候才会回收软引用</li>
<li>当发生GC的时候弱引用就会被回收掉</li>
</ul>
</li>
<li>虚引用和终结器引用必须结合引用队列来使用</li>
</ul>
</blockquote>
<p>四种引用强度(不包含终结器引用)从大到小分别是：<strong>强引用-&gt;软引用-&gt;弱引用-&gt;虚引用</strong></p>
<p><strong>参考图</strong>（下图中有两个<code>GC Root</code>， 实线表示强引用）</p>
<p><img src="/2020/04/23/java/jvm/jvm/1574564711687.png" alt></p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用表示从<code>GC Root</code>出发可以直接达到的，比如<code>Oeject object = new Object()</code>这类引用就是强引用。只要强引用还在，垃圾回收器就不会回收掉被引用的对象。</p>
<p>比如上面的<code>A1</code>对象被<code>B</code>对象和<code>C</code>对象都是直接引用到(当然实际上只要有一个强引用就可以算是强引用)，所以是一个强引用。</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用用来描述一些还有用但是不是必须的对象，对于软引用关联着的对象，在系统中<strong>将要发生内存溢出异常之前</strong>，将会把这些对象列进回收范围之内进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常，在<code>jdk1.2</code>之后，提供了<code>SoftReference</code>类来实现软引用。</p>
<p>比如上面的<code>A2</code>对象如果是从<code>C</code>对象的角度来看是一个软件用。（当然从B对象来看是强引用，所以垃圾回收是不会回收该对象的）</p>
<p><strong>软引用案例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置堆内存大小为<code>20M</code></p>
<p><img src="/2020/04/23/java/jvm/jvm/1574567017819.png" alt></p>
<p>运行程序出现堆内存溢出错误：</p>
<p><img src="/2020/04/23/java/jvm/jvm/1574567090459.png" alt></p>
<p>将程序修改为软引用的形式来做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        soft();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">soft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; reference = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">            System.out.println(reference.get());</span><br><span class="line">            list.add(reference);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"循环结束"</span>);</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时不会出现堆内存溢出错误而且<code>list</code>中前面四个都已经被回收掉了。当然除了配置堆内存大小外还可以配置显示gc回收的虚拟机运行参数；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用也是用来描述非必须的对象的，但是它的强度比软引用更弱一些，被弱引用关联的软引用只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，<strong>无论当前内存是否足够，都会回收掉被弱引用关联的对象</strong>，在<code>jdk1.2</code>之后，提供了<code>WeakReference</code>类来实现弱引用。</p>
<h4 id="软弱引用与引用队列"><a href="#软弱引用与引用队列" class="headerlink" title="软弱引用与引用队列"></a>软弱引用与引用队列</h4><p>软引用与若引用的区别在于他们的回收时机</p>
<ul>
<li>软引用是只有当内存空间不足时才会被回收</li>
<li>弱引用是无论内存空间是否足够都是会被回收的</li>
</ul>
<p>从上面的图可以看到，软引用与弱引用可以认为是间接引用，也就是根对象首先强引用一个软引用或弱引用，然后该软引用或弱引用再来引用一个对象，那么当这个对象（比如A2）当被回收时，<code>A2</code>所对应的软引用也是会占有一定的内存的，如果想要回收这个内存空间就需要<code>A2</code>对应的软引用进入到引用队列中，然后在引用队列中进行遍历的时候回收这个内存(对于弱引用也是同样的道理)。</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p><strong>软弱引用可以配置引用队列使用，也可以不用配合引用队列来使用，但是虚引用就必须配合引用队列来使用</strong></p>
<p>虚引用也被称为幽灵引用或幻影引用，他是最弱的一种引用关系，一个对象是否与虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通过，在<code>jdk1.2</code>之后，提供了<code>PhantomReference</code>来实现虚引用。</p>
<p><strong>使用案例：</strong></p>
<p>当我们使用<code>ByteBuffer</code>时是会创建一个直接内存，同时也会创建一个<code>Cleaner</code>的虚引用，当<code>ByteBuffer</code>被垃圾回收时，它所分配的直接内存是不会被回收的，因为直接内存是不受<code>java</code>虚拟机管理的，此时就需要使用的<code>Cleaner</code>的虚引用了，因为当<code>ByteBuffer</code>回收时，该虚引用就会进入到引用队列，引用队列里面会检测是否有<code>Cleaner</code>虚引用，如果有就会调用<code>clear</code>方法，该方法最终会调用<code>Unsafe.freeMemory()</code>来释放掉这一块直接内存。</p>
<h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><p>终结器引用也是需要配合引用队列来使用的。</p>
<p>每一个对象都有一个终极父类<code>Object</code>，<code>Object</code>类中有一个<code>finalize()</code>方法，如果我们重写了这个方法，那么这个方法的调用时机是什么呢?这就需要使用的终结器引用了。<strong>当没有强引用来关联该对象的时候，虚拟机会帮我们创建终结器匀变速，并终结器就会进入到引用队列(此时该对象还没有被回收)。</strong>有一个优先级很低的线程会检查引用队列中是否有终结器引用，如果有就会根据该终结器引用找到对应对象的<code>finalize()</code>方法。</p>
<p><font color="red">注意：通过终结器引用来释放资源的方式效率很低，多以一般是不推荐使用finalize()方法了释放资源。</font></p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ul>
<li>速度快</li>
<li>会造成内存碎片</li>
</ul>
<p><img src="/2020/04/23/java/jvm/jvm/1574575683561.png" alt="1574575683561"></p>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><ul>
<li>速度慢</li>
<li>没有内存碎片</li>
</ul>
<p><img src="/2020/04/23/java/jvm/jvm/1574575714962.png" alt="1574575714962"></p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul>
<li>没有内存碎片</li>
<li>需要占用双倍的内存空间</li>
</ul>
<p><img src="/2020/04/23/java/jvm/jvm/1574575757476.png" alt="1574575757476"></p>
<p><code>jvm</code>中并不是只是使用某一种算法，而是在不同的情形下会使用不同的算法，也有可能结合起来使用。</p>
<h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><p><img src="/2020/04/23/java/jvm/jvm/1574576757717.png" alt="1574576757717"></p>
<ul>
<li>对象首先分配在<strong>伊甸园</strong>区域</li>
<li>新生代空间不足时，触发<code>minor gc</code>,伊甸园和<code>from</code>区存活的对象使用<strong>复制算法</strong>复制到<code>to</code>区，存活的对象年龄加1并且交换<code>from</code>区和<code>to</code>区</li>
<li><code>minor gc</code>会引发 <code>stop the world</code>,暂停其他用户的线程，等待垃圾回收结束，用户线程才恢复</li>
<li>当对象寿命超过阈值时，会将对象移入到老年代，最大寿命是15(使用4bit来存储该值，所以最大是15)</li>
<li>当老年代空间不足，会先尝试触发 <code>minor gc</code>，如果之后空间还是不足，那么会触发<code>full gc</code>,<code>SWT</code>的时间更长。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
</search>
